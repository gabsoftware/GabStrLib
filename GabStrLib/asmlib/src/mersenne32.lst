Microsoft (R) Macro Assembler Version 9.00.21022.08	    08/06/09 23:17:55
mersenne32.asm						     Page 1 - 1


				; ----------------------------- MERSENNE32.ASM ---------------------------
				;  Random Number generator 'Mersenne Twister' type MT11213A (or MT19937)
				;  AgF 2007-08-06
				;
				;  This random number generator is described in the article by
				;  M. Matsumoto & T. Nishimura, in:
				;  ACM Transactions on Modeling and Computer Simulation,
				;  vol. 8, no. 1, 1998, pp. 3-30. See also:
				;  http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
				;
				;  Initialization:
				;  MersRandomInit must be called before the first call to any of the other
				;  random number functions. The seed is any 32-bit integer.
				;  You may use MersRandomInitByArray instead if you want more
				;  than 32 bits for seed. length is the number of integers in seeds[].
				;  length must be > 0, there is no upper limit for length.
				;
				;  Generating random numbers:
				;  MersRandom returns a floating point number in the interval 0 <= x < 1 with
				;  a resolution of 32 bits.
				;  MersIRandom returns an integer in the interval defined by min and max with
				;  a resolution of 32 bits.
				;  MersIRandomX returns an integer in the interval defined by min and max with
				;  exactly equal probabilities of all values in the interval.
				;  MersBRandom returns 32 random bits.
				;
				;  Error conditions:
				;  If MersRandomInit or MersRandomInitByArray has not been called then MersRandom
				;  and MersBRandom keep returning 0, and MersIRandom and MersIRandomX return min.
				;  MersIRandom and MersIRandomX return a large negative number if max < min.
				;
				;  C++ prototypes in randoma.h, 32-bit Windows:
				;
				;  Thread-safe static link versions for Mersenne Twister
				;  extern "C" void   MersRandomInit(void * Pthis, int seed);              // Re-seed
				;  extern "C" void   MersRandomInitByArray(void * Pthis, unsigned int seeds[], int length); // Seed by more than 32 bits
				;  extern "C" int    MersIRandom (void * Pthis, int min, int max);        // Output random integer
				;  extern "C" int    MersIRandomX(void * Pthis, int min, int max);        // Output random integer, exact
				;  extern "C" double MersRandom(void * Pthis);                            // Output random float
				;  extern "C" unsigned int MersBRandom(void * Pthis);                     // Output random bits
				;
				;  Single-threaded static link versions for Mersenne Twister, Windows only
				;  extern "C" void   MersenneRandomInit(int seed);              // Re-seed
				;  extern "C" void   MersenneRandomInitByArray(unsigned int seeds[], int length); // Seed by more than 32 bits
				;  extern "C" int    MersenneIRandom (int min, int max);        // Output random integer
				;  extern "C" int    MersenneIRandomX(int min, int max);        // Output random integer, exact
				;  extern "C" double MersenneRandom();                          // Output random float
				;  extern "C" unsigned int MersenneBRandom();                   // Output random bits
				;
				;  Single threaded dynamic link versions for Mersenne Twister, Windows only
				;  extern "C" void   __stdcall MersenneRandomInitD(int seed);              // Re-seed
				;  extern "C" void   __stdcall MersenneRandomInitByArrayD(unsigned int seeds[], int length); // Seed by more than 32 bits
				;  extern "C" int    __stdcall MersenneIRandomD (int min, int max);        // Output random integer
				;  extern "C" int    __stdcall MersenneIRandomXD(int min, int max);        // Output random integer, exact
				;  extern "C" double __stdcall MersenneRandomD();                          // Output random float
				;  extern "C" unsigned int __stdcall MersenneBRandomD();                   // Output random bits
				;
				;
				;  © 1998 - 2008 Agner Fog. 
				;  See asmlib-instructions.pdf for license conditions
				; ----------------------------------------------------------------------
				.686
				.xmm
				.model flat

				; structure definition and constants:
				INCLUDE randomah.asi
			      C ; ----------------------------- RANDOMAH.ASI ---------------------------
			      C ;
			      C ;  Assembly include file containing
			      C ;  structure/class definitions for random number generators
			      C ;
			      C ;  © 2001, 2007 Agner Fog.
			      C ;  GNU General Public License www.gnu.org/copyleft/gpl.html
			      C ; ----------------------------------------------------------------------
			      C 
			      C ; Definitions for Mersenne Twister:
			      C 
 = 00000001		      C TEMPERING EQU 1              ; set to 0 if no tempering (improves speed by 25%)
			      C 
			      C IF 0
			      C ELSE
			      C ; or constants for MT19937:
 = 00000270		      C MERS_N    = 624
 = 0000018D		      C MERS_M    = 397
 = 0000001F		      C MERS_R    = 31
 = 9908B0DF		      C MERS_A    = 09908B0DFH
 = 0000000B		      C MERS_U    = 11
 = 00000007		      C MERS_S    = 7
 = 0000000F		      C MERS_T    = 15
 = 00000012		      C MERS_L    = 18
 = 9D2C5680		      C MERS_B    = 9D2C5680H
 = EFC60000		      C MERS_C    = 0EFC60000H
			      C 
			      C ENDIF
			      C 
 = 7FFFFFFF		      C LOWER_MASK = (1 SHL MERS_R) - 1             ; lower MERS_R bits
 = 80000000		      C UPPER_MASK = -1 SHL MERS_R                  ; upper 32-MERS_R bits
			      C 
			      C ; Define class CRandomMersenneA member data
			      C ; Must be aligned by 16.
			      C 
 00000A70		      C CRandomMersenneA STRUC
 00000000  00000000	      C PreInt  DD      ?, ?, ?, ?             ; premade tempered integer numbers, ready to use
	   00000000
	   00000000
	   00000000
 00000010  0000000000000000   C PreFlt  DQ      ?, ?, ?, ?             ; premade floating point numbers, ready to use (subtract 1.0)
	   0000000000000000
	   0000000000000000
	   0000000000000000
 00000030  0000000000000000   C         DQ      ?                      ; last PreFlt unaligned overrun if MERS_N mod 4 = 1
 00000038  0000000000000000   C TmpFlt  DQ      ?                      ; temporary storage of floating point random number
 00000040  00000000	      C PreInx  DD      ?                      ; index to next PreInt and PreFlt number
 00000044  00000000	      C Instset DD      ?                      ; Instruction set
 00000048  00000000	      C LastInterval DD ?                      ; Last interval length for IRandomX
 0000004C  00000000	      C RLimit  DD      ?                      ; Rejection limit used by IRandomX
 00000050  00000004 [	      C TMB     DD      4 dup (?)              ; 4 copies of MERS_B constant
	    00000000
	   ]
 0DD0005C  00000004 [	      C TMC     DD      4 dup (?)              ; 4 copies of MERS_C constant
	    00000000
	   ]
 1BA00068  00000002 [	      C one     DQ      2 dup (?)              ; 2 copies of 1.0 constant
	    0000000000000000
	   ]
 37400080  00000000	      C MTI     DD      ?                      ; index into MT buffer
 37400084  00000000	      C UMASK   DD      ?                      ; UPPER_MASK
 37400088  00000000	      C LMASK   DD      ?                      ; LOWER_MASK             ; constants
 3740008C  00000000	      C MATA    DD      ?                      ; MERS_A
 37400090  00000004 [	      C wrap1   DD      4  dup (?)             ; MT buffer km wraparound
	    00000000
	   ]
 4510009C  00000270 [	      C MT      DD      MERS_N  dup (?)        ; MT history buffer (aligned by 16)
	    00000000
	   ]
 52E000A8  00000004 [	      C wrap2   DD      4  dup (?)             ; MT buffer kk wraparound
	    00000000
	   ]
			      C IF MERS_N AND 3
			      C ENDIF        
			      C CRandomMersenneA ENDS
			      C 
			      C 
			      C ; Definitions for Mother-of-all generator:
			      C 
			      C ; Define class CRandomMotherA member data
			      C ; Must be aligned by 16. Preferably aligned by 64 to fit a cache line
 00000040		      C CRandomMotherA STRUC
 00000000  0000000000000000   C one     DQ      ?                      ; 1.0
 00000008  00000000	      C Instset DD      ?                      ; Instruction set
 0000000C  00000000	      C M4      DD      ?                      ; x[n-4]
 00000010  00000000	      C M3      DD      ?                      ; x[n-3] (aligned)
 00000014  00000000	      C M2      DD      ?                      ; x[n-2]
 00000018  00000000	      C M1      DD      ?                      ; x[n-1]
 0000001C  00000000	      C M0      DD      ?                      ; x[n]
 00000020  00000000	      C MC      DD      ?                      ; Carry (aligned)
 00000024  00000000	      C zero    DD      ?                      ; Zero-extension of carry
 00000028  0000000000000000   C RanP1   DQ      ?                      ; Double random number in interval [1,2)
 00000030  00000000	      C MF3     DD      ?                      ; 2111111111 (aligned)
 00000034  00000000	      C MF2     DD      ?                      ; 1492
 00000038  00000000	      C MF1     DD      ?                      ; 1776
 0000003C  00000000	      C MF0     DD      ?                      ; 5115
			      C CRandomMotherA ENDS
			      C 

				IFNDEF POSITIONINDEPENDENT
 00000000			.DATA
				; Data for single instance of random number generator
 00000000 00000000		MersenneInstance CRandomMersenneA <>
	   00000000
	   00000000
	   00000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000004 [
	    00000000
	   ]
	   00000004 [
	    00000000
	   ]
	   00000002 [
	    0000000000000000
	   ] 00000000
	   00000000
	   00000000
	   00000000
	   00000004 [
	    00000000
	   ]
	   00000270 [
	    00000000
	   ]
	   00000004 [
	    00000000
	   ]
				ENDIF


 00000000			.CODE

				extern _InstructionSet: near


				; ---------------------------------------------------------------
				;  Thread-safe static link versions for Mersenne Twister
				; ---------------------------------------------------------------

				;  extern "C" void MersRandomInit(void * Pthis, int seed); // Re-seed

 00000000			_MersRandomInit PROC NEAR
 00000000  8B 4C 24 04		        mov     ecx, [esp+4]           ; Pthis
				assume  ecx: ptr CRandomMersenneA
 00000004  8B 44 24 08		        mov     eax, [esp+8]           ; seed
				        
 00000008			MersRandomInit_reg  LABEL NEAR         ; Entry for register parameters, used internally
				;public MersRandomInit_reg

 00000008  E8 00000020		        call    Mers_init0             ; initialize mt buffer with seeds
				        
				        ; Number of premade numbers that are lost in the initialization when the  
				        ; SSE2 implementation makes up to 4 premade numbers at a time:
				IF MERS_N and 3        
				ELSE
 = 00000004			   PREMADELOST = 4
				ENDIF
				        ; We want the C++ and the assembly implementation to give exactly the same
				        ; sequence. The C++ version discards 37 random numbers after initialization.
				        ; The assembly version generates a sequence that is PREMADELOST + 1 numbers
				        ; behind. Therefore we discard the first 37 + PREMADELOST + 1 numbers if
				        ; SSE2 is supported, otherwise 37 + 1.
				        
 0000000D  57			        push    edi
 0000000E  BF 0000002A		        mov     edi, 37+PREMADELOST+1
 00000013  83 79 44 04		        CMP     [ecx].Instset, 4       ; can we use XMM registers and SSE2 ?
 00000017  73 0A		        jae     M110
 00000019  83 EF 04		        sub     edi, PREMADELOST       ; SSE2 not supported
 0000001C  C7 41 40		        mov     [ecx].PreInx, 0        ; reset index to premade list
	   00000000
 00000023			M110:   ; loop
 00000023  E8 000001AA		M120:   call    MersBRandom_reg
 00000028  4F			        dec     edi
 00000029  75 F8		        jnz     M120
 0000002B  5F			        pop     edi
 0000002C  C3			        ret
 0000002D			_MersRandomInit ENDP
				        

 0000002D			Mers_init0   PROC    NEAR    ; make random seeds from eax and put them into MT buffer
				; Input parameters: 
				; eax: seed
				; ecx points to CRandomMersenneA
				assume  ecx: ptr CRandomMersenneA

 0000002D  53			        push    ebx
 0000002E  57			        push    edi
 0000002F  8B D8		        mov     ebx, eax               ; seed
				        
				        ; clear my buffer
 00000031  51			        push    ecx
 00000032  8B F9		        mov     edi, ecx               ; Pthis
 00000034  B9 0000029C		        mov     ecx, (type CRandomMersenneA) / 4
 00000039  33 C0		        xor     eax, eax
 0000003B  FC			        cld
 0000003C  F3/ AB		        rep     stosd
 0000003E  59			        pop     ecx                    ; Pthis
				        
				        ; initialize CRandomMersenneA structure
 0000003F  C7 41 40		        mov     [ecx].PreInx, 4*4
	   00000010
 00000046  51			        push    ecx
 00000047  E8 00000000 E	        call    _InstructionSet        ; detect instruction set
 0000004C  59			        pop     ecx
 0000004D  89 41 44		        mov     [ecx].Instset, eax
 00000050  B8 9D2C5680		        mov     eax, MERS_B
 00000055  89 41 50		        mov     [ecx].TMB, eax
 00000058  89 41 54		        mov     [ecx].TMB+4, eax
 0000005B  89 41 58		        mov     [ecx].TMB+8, eax
 0000005E  89 41 5C		        mov     [ecx].TMB+12, eax
 00000061  B8 EFC60000		        mov     eax, MERS_C
 00000066  89 41 60		        mov     [ecx].TMC, eax
 00000069  89 41 64		        mov     [ecx].TMC+4, eax
 0000006C  89 41 68		        mov     [ecx].TMC+8, eax
 0000006F  89 41 6C		        mov     [ecx].TMC+12, eax
 00000072  B8 3FF00000		        mov     eax, 3FF00000H         ; upper dword of 1.0, double precision
 00000077  89 41 74		        mov     dword ptr [ecx].one+4, eax
 0000007A  89 41 7C		        mov     dword ptr [ecx].one+12, eax        
 0000007D  C7 81 00000088	        mov     [ecx].LMASK, LOWER_MASK
	   7FFFFFFF
 00000087  C7 81 00000084	        mov     [ecx].UMASK, UPPER_MASK
	   80000000
 00000091  C7 81 0000008C	        mov     [ecx].MATA,  MERS_A
	   9908B0DF

				        ; put random numbers into MT buffer
 0000009B  33 FF		        xor     edi, edi        
 0000009D  89 9C B9		M210:   mov     [ecx+edi*4].MT, ebx
	   000000A0
 000000A4  8B D3		        mov     edx, ebx
 000000A6  C1 EB 1E		        shr     ebx, 30
 000000A9  33 DA		        xor     ebx, edx
 000000AB  69 DB 6C078965	        imul    ebx, 1812433253D
 000000B1  47			        inc     edi
 000000B2  03 DF		        add     ebx, edi        
 000000B4  81 FF 00000270	        cmp     edi, MERS_N
 000000BA  72 E1		        jb      M210
				        
				        ; Set index MTI to end of list, (scaled by 4)
				        ; Round up to multiple of 4 to avoid alignment error
 000000BC  C7 81 00000080	        mov     [ecx].MTI, ((MERS_N+3) and -4) * 4
	   000009C0
				        
 000000C6  5F			        pop     edi
 000000C7  5B			        pop     ebx       
 000000C8  C3			        ret      
 000000C9			Mers_init0   ENDP


				;  extern "C" void   MersRandomInitByArray(void * Pthis, unsigned int seeds[], int length); // Seed by more than 32 bits
 000000C9			_MersRandomInitByArray PROC NEAR

 000000C9  53			        push    ebx
 000000CA  56			        push    esi
 000000CB  57			        push    edi
 000000CC  55			        push    ebp
 000000CD  8B 4C 24 14		        mov     ecx, [esp+20]          ; Pthis
 000000D1  8B 5C 24 18		        mov     ebx, [esp+24]          ; seeds
 000000D5  8B 6C 24 1C		        mov     ebp, [esp+28]          ; length
				assume  ecx: ptr CRandomMersenneA
				        
 000000D9			MersRandomInitByArray_reg  LABEL NEAR  ; Entry for register parameters, used internally
				;public MersRandomInitByArray_reg

 000000D9  55			        push    ebp                    ; save length
 000000DA  B8 012BD6AA		        mov     eax, 19650218
 000000DF  E8 FFFFFF49		        call    Mers_init0             ; init0(19650218);
				        
 000000E4  85 ED		        test    ebp, ebp
 000000E6  0F 8E 000000AE	        jle     M380                   ; error: length <= 0
 000000EC  33 FF		        xor     edi, edi               ; j = 0
 000000EE  8D 77 01		        lea     esi, [edi+1]           ; i = 1
 000000F1  81 FD 00000270	        cmp     ebp, MERS_N
 000000F7  77 05		        ja      M310
 000000F9  BD 00000270		        mov     ebp, MERS_N            ; k = max (MERS_N,length)
 000000FE			M310:

				        ; for (; k; k--) {
 000000FE  8B 84 B1		M320:   mov     eax, [ecx+esi*4-4].MT  ; mt[i-1]
	   0000009C
 00000105  8B D0		        mov     edx, eax
 00000107  C1 E8 1E		        shr     eax, 30
 0000010A  33 C2		        xor     eax, edx               ; mt[i-1] ^ (mt[i-1] >> 30)
 0000010C  69 C0 0019660D	        imul    eax, 1664525           ; * 1664525
 00000112  33 84 B1		        xor     eax, [ecx+esi*4].MT       ; ^ mt[i]
	   000000A0
 00000119  03 04 BB		        add     eax, [ebx+edi*4]       ; + seeds[j]
 0000011C  03 C7		        add     eax, edi               ; + j
 0000011E  89 84 B1		        mov     [ecx+esi*4].MT, eax       ; save in mt[i]
	   000000A0
 00000125  46			        inc     esi                    ; i++
 00000126  47			        inc     edi                    ; j++
 00000127  81 FE 00000270	        cmp     esi, MERS_N
 0000012D  72 11		        jb      M330                   ; if (i>=MERS_N)
 0000012F  8B 81 00000A5C	        mov     eax, [ecx+(MERS_N-1)*4].MT     ; mt[0] = mt[MERS_N-1];
 00000135  89 81 000000A0	        mov     [ecx].MT, eax
 0000013B  BE 00000001		        mov     esi, 1                 ; i=1;
 00000140			M330:
 00000140  3B 3C 24		        cmp     edi, [esp]             ; length
 00000143  72 02		        jb      M340          ; if (j>=length)
 00000145  33 FF		        xor     edi, edi               ; j = 0;
 00000147			M340:
 00000147  4D			        dec     ebp                    ; k--
 00000148  75 B4		        jnz     M320                   ; first k loop
 0000014A			M350:
 0000014A  BD 0000026F		        mov     ebp, MERS_N-1          ; k
 0000014F  8B 84 B1		M360:   mov     eax, [ecx+esi*4-4].MT  ; mt[i-1]
	   0000009C
 00000156  8B D0		        mov     edx, eax
 00000158  C1 E8 1E		        shr     eax, 30
 0000015B  33 C2		        xor     eax, edx               ; mt[i-1] ^ (mt[i-1] >> 30)
 0000015D  69 C0 5D588B65	        imul    eax, 1566083941        ; * 1566083941
 00000163  33 84 B1		        xor     eax, [ecx+esi*4].MT    ; ^ mt[i]
	   000000A0
 0000016A  2B C6		        sub     eax, esi               ; - i
 0000016C  89 84 B1		        mov     [ecx+esi*4].MT, eax    ; save in mt[i]
	   000000A0
 00000173  46			        inc     esi                    ; i++
 00000174  81 FE 00000270	        cmp     esi, MERS_N
 0000017A  72 11		        jb      M370                   ; if (i>=MERS_N)
 0000017C  8B 81 00000A5C	        mov     eax, [ecx+(MERS_N-1)*4].MT  ; mt[0] = mt[MERS_N-1];
 00000182  89 81 000000A0	        mov     [ecx].MT, eax
 00000188  BE 00000001		        mov     esi, 1                 ; i=1;
 0000018D			M370:
 0000018D  4D			        dec     ebp                    ; k--
 0000018E  75 BF		        jnz     M360                   ; second k loop
 00000190  C7 81 000000A0	        mov     [ecx].MT, 80000000H    ; mt[0] = 0x80000000
	   80000000
 0000019A			M380:
 0000019A  C7 81 00000080	        mov     [ecx].MTI, 0
	   00000000
 000001A4  C7 41 40		        mov     [ecx].PreInx, 0
	   00000000

				; discard first MERS_N random numbers + PREMADELOST+1 to compensate for lag
 000001AB  BF 00000275		        mov     edi, MERS_N + PREMADELOST+1
 000001B0  83 79 44 04		        CMP     [ecx].Instset, 4       ; can we use XMM registers and SSE2 ?
 000001B4  73 0A		        jae     M390
 000001B6  83 EF 04		        sub     edi, PREMADELOST       ; SSE2 not supported
 000001B9  C7 41 40		        mov     [ecx].PreInx, 0        ; reset index to premade list
	   00000000
 000001C0			M390:   ; loop
 000001C0  E8 0000000D		M391:   call    MersBRandom_reg
 000001C5  4F			        dec     edi
 000001C6  75 F8		        jnz     M391

 000001C8  59			        pop     ecx                    ; remove local copy of length
 000001C9  5D			        pop     ebp                    ; restore registers
 000001CA  5F			        pop     edi
 000001CB  5E			        pop     esi
 000001CC  5B			        pop     ebx
 000001CD  C3			        ret
 000001CE			_MersRandomInitByArray ENDP

				;  extern "C" unsigned int MersBRandom(void * Pthis);                     // Output random bits

 000001CE			_MersBRandom PROC NEAR                 ; generate random bits
 000001CE  8B 4C 24 04		        mov     ecx, [esp+4]           ; Pthis
				assume  ecx: ptr CRandomMersenneA

 000001D2			MersBRandom_reg  LABEL NEAR            ; Entry for register parameters, used internally
				;public MersBRandom_reg

 000001D2  83 79 44 04		        cmp     [ecx].Instset, 4       ; can we use XMM registers and SSE2 ?
 000001D6  0F 82 0000017E	        jb      M500

				        ; this version uses XMM registers and SSE2 instructions:
 000001DC  8B 51 40		        mov     edx, [ecx].PreInx      ; index into premade numbers
 000001DF  8B 04 11		        mov     eax, [ecx+edx*1].PreInt; fetch premade random number
 000001E2  83 C2 04		        add     edx, 4
 000001E5  89 51 40		        mov     [ecx].PreInx, edx
 000001E8  83 FA 10		        cmp     edx, 4*4
 000001EB  73 01		        jnb     M410
 000001ED  C3			        ret                            ; return premade number

 000001EE			M410    LABEL   NEAR
				; PREMADE list is empty. Make 4 more numbers ready for next call:
 000001EE  8B 91 00000080	        mov     edx, [ecx].MTI         ; fetch 4 numbers from MT buffer
 000001F4  66| 0F 6F 84 11	        movdqa  xmm0, xmmword ptr [ecx+edx*1].MT
	   000000A0
				        
				IF TEMPERING                           ; optional tempering algorithm
 000001FD  66| 0F 6F C8		        movdqa  xmm1, xmm0
 00000201  66| 0F 72 D0		        psrld   xmm0, MERS_U
	   0B
 00000206  66| 0F EF C1		        pxor    xmm0, xmm1
 0000020A  66| 0F 6F C8		        movdqa  xmm1, xmm0        
 0000020E  66| 0F 72 F0		        pslld   xmm0, MERS_S
	   07
 00000213  66| 0F DB 41		        pand    xmm0, xmmword ptr [ecx].TMB
	   50
 00000218  66| 0F EF C1		        pxor    xmm0, xmm1
 0000021C  66| 0F 6F C8		        movdqa  xmm1, xmm0        
 00000220  66| 0F 72 F0		        pslld   xmm0, MERS_T
	   0F
 00000225  66| 0F DB 41		        pand    xmm0, xmmword ptr [ecx].TMC
	   60
 0000022A  66| 0F EF C1		        pxor    xmm0, xmm1
 0000022E  66| 0F 6F C8		        movdqa  xmm1, xmm0        
 00000232  66| 0F 72 D0		        psrld   xmm0, MERS_L
	   12
 00000237  66| 0F EF C1		        pxor    xmm0, xmm1
				ENDIF   ; tempering

				        ; save four premade integers
 0000023B  66| 0F 7F 01		        movdqa  xmmword ptr [ecx].PreInt, xmm0
				        ; premake four floating point numbers
 0000023F  66| 0F EF C9		        pxor    xmm1, xmm1
 00000243  66| 0F EF D2		        pxor    xmm2, xmm2
 00000247  66| 0F 62 C8		        punpckldq xmm1, xmm0           ; get first two numbers into bits 32-63 and 96-127
 0000024B  66| 0F 6A D0		        punpckhdq xmm2, xmm0           ; get next  two numbers into bits 32-63 and 96-127
 0000024F  66| 0F 73 D1		        psrlq   xmm1, 12               ; get bits into mantissa position
	   0C
 00000254  66| 0F 73 D2		        psrlq   xmm2, 12               ; get bits into mantissa position
	   0C
 00000259  66| 0F EB 49		        por     xmm1, xmmword ptr [ecx].one ; set exponent for interval [1,2)
	   70
 0000025E  66| 0F EB 51		        por     xmm2, xmmword ptr [ecx].one ; set exponent for interval [1,2)
	   70
 00000263  66| 0F 7F 49		        movdqa  xmmword ptr [ecx].PreFlt, xmm1     ; store two premade numbers
	   10
 00000268  66| 0F 7F 51		        movdqa  xmmword ptr [ecx].PreFlt+16, xmm2  ; store two more premade numbers        
	   20
 0000026D  C7 41 40		        mov     [ecx].PreInx, 0        ; index to premade numbers 
	   00000000
 00000274  83 C2 10		        add     edx, 4*4               ; increment MTI index into MT buffer by 4
 00000277  89 91 00000080	        mov     [ecx].MTI, edx
 0000027D  81 FA 000009C0	        cmp     edx, MERS_N*4
 00000283  73 01		        jae     M420
 00000285  C3			        ret                            ; return random number in eax

				; MT buffer exhausted. Make MERS_N new numbers ready for next time
 00000286			M420:                                  ; eax is the random number to return
				IF      MERS_N AND 3                   ; if MERS_N is not divisible by 4
				ENDIF
				        
				        ; MT buffer is empty. Fill it up
 00000286  53			        push    ebx
 00000287  66| 0F 6E 99		        movd    xmm3, [ecx].UMASK      ; load constants
	   00000084
 0000028F  66| 0F 6E A1		        movd    xmm4, [ecx].LMASK
	   00000088
 00000297  66| 0F 6E A9		        movd    xmm5, [ecx].MATA
	   0000008C
 0000029F  66| 0F 70 DB		        pshufd  xmm3, xmm3, 0          ; broadcast constants
	   00
 000002A4  66| 0F 70 E4		        pshufd  xmm4, xmm4, 0
	   00
 000002A9  66| 0F 70 ED		        pshufd  xmm5, xmm5, 0
	   00
 000002AE  33 DB		        xor     ebx,  ebx              ; kk = 0
 000002B0  BA 00000634		        mov     edx,  MERS_M*4         ; km
				        
				; change ecx from pointing to CRandomMersenneA to pointing to CRandomMersenneA.MT
 000002B5  81 C1 000000A0	        add     ecx, CRandomMersenneA.MT
				        assume  ecx: ptr dword

 000002BB			M430:   ; kk loop
 000002BB  66| 0F 6F 14 0B	        movdqa  xmm2, xmmword ptr [ecx+ebx]        ; mt[kk]
 000002C0  66| 0F 6E 74 0B	        movd    xmm6, [ecx+ebx+16]
	   10
 000002C6  66| 0F 6F 0C 0B	        movdqa  xmm1, xmmword ptr [ecx+ebx]        ; mt[kk]        
 000002CB  F3/ 0F 10 D6		        movss   xmm2, xmm6             ; faster than movdqu xmm2, [ebx+4]
 000002CF  66| 0F 70 D2		        pshufd  xmm2, xmm2, 00111001B  ; mt[kk+1]
	   39
 000002D4  F3/ 0F 7E 04 0A	        movq    xmm0, qword ptr [ecx+edx]; mt[km]
 000002D9  0F 16 44 0A 08	        movhps  xmm0, qword ptr [ecx+edx+8] ; faster than movdqu xmm0, [edx]
 000002DE  66| 0F DB CB		        pand    xmm1, xmm3             ; mt[kk] & UPPER_MASK
 000002E2  66| 0F DB D4		        pand    xmm2, xmm4             ; mt[kk+1] & LOWER_MASK
 000002E6  66| 0F EB CA		        por     xmm1, xmm2             ; y        
 000002EA  66| 0F 6F D1		        movdqa  xmm2, xmm1             ; y
 000002EE  66| 0F 72 F1		        pslld   xmm1, 31               ; copy bit 0 into all bits
	   1F
 000002F3  66| 0F 72 E1		        psrad   xmm1, 31               ; -(y & 1)
	   1F
 000002F8  66| 0F DB CD		        pand    xmm1, xmm5             ; & MERS_A
 000002FC  66| 0F 72 D2		        psrld   xmm2, 1                ; y >> 1
	   01
 00000301  66| 0F EF C1		        pxor    xmm0, xmm1
 00000305  66| 0F EF C2		        pxor    xmm0, xmm2
 00000309  66| 0F 7F 04 0B	        movdqa  xmmword ptr [ecx+ebx], xmm0        ; result into mt[kk]
 0000030E  81 FB 000009B0	        cmp     ebx, (MERS_N-4)*4
 00000314  73 32		        jae     M440                   ; exit loop when kk past end of buffer
 00000316  83 C3 10		        add     ebx, 16                ; kk += 4
 00000319  83 C2 10		        add     edx, 16                ; km += 4
 0000031C  81 FA 000009B0	        cmp     edx, (MERS_N-4)*4
 00000322  76 97		        jbe     M430                   ; skip unless km wraparound
 00000324  81 EA 000009C0	        sub     edx, MERS_N*4          ; km wraparound
 0000032A  F3/ 0F 6F 81		        movdqu  xmm0, xmmword ptr [ecx]+(MERS_N-4)*4 ; copy end to before begin for km wraparound
	   000009B0
 00000332  66| 0F 7F 41		        movdqa  xmmword ptr [ecx]-4*4, xmm0        
	   F0
 00000337  66| 0F 6F 01		        movdqa  xmm0, xmmword ptr [ecx]            ; copy begin to after end for kk wraparound
 0000033B  F3/ 0F 7F 81		        movdqu  xmmword ptr [ecx]+MERS_N*4, xmm0
	   000009C0
 00000343  E9 FFFFFF73		        jmp     M430

 00000348			M440:   ; loop finished. discard excess part of last result

				; change ecx back to pointing to CRandomMersenneA
 00000348  81 E9 000000A0	        sub     ecx, CRandomMersenneA.MT        
				assume  ecx: ptr CRandomMersenneA

 0000034E  C7 81 00000080	        mov     [ecx].MTI, 0
	   00000000
 00000358  5B			        pop     ebx
 00000359  C3			        ret                            ; random number is still in eax
				        
				; Generic version        
				; this version is for old processors without XMM support:
 0000035A			M500    label near
 0000035A  8B 91 00000080	        mov     edx, [ecx].MTI
 00000360  81 FA 000009C0	        cmp     edx, MERS_N*4
 00000366  73 50		        jnb     short M520             ; buffer is empty, fill it   
 00000368  8B 84 11		M510:   mov     eax, [ecx+edx*1].MT
	   000000A0
 0000036F  83 C2 04		        add     edx, 4
 00000372  89 91 00000080	        mov     [ecx].MTI, edx
				        
				IF TEMPERING   
 00000378  8B D0		        mov     edx, eax
 0000037A  C1 E8 0B		        shr     eax, MERS_U
 0000037D  33 C2		        xor     eax, edx
 0000037F  8B D0		        mov     edx, eax
 00000381  C1 E0 07		        shl     eax, MERS_S
 00000384  25 9D2C5680		        and     eax, MERS_B
 00000389  33 C2		        xor     eax, edx
 0000038B  8B D0		        mov     edx, eax
 0000038D  C1 E0 0F		        shl     eax, MERS_T
 00000390  25 EFC60000		        and     eax, MERS_C
 00000395  33 C2		        xor     eax, edx
 00000397  8B D0		        mov     edx, eax
 00000399  C1 E8 12		        shr     eax, MERS_L
 0000039C  33 C2		        xor     eax, edx
				ENDIF   ; tempering

 0000039E  8B 11		        mov     edx, [ecx].PreInt      ; previously premade number
 000003A0  89 01		        mov     [ecx].PreInt, eax      ; store number for next call
 000003A2  C1 E0 14		        shl     eax, 20                ; convert to float
 000003A5  89 41 10		        mov     dword ptr [ecx].PreFlt, eax
 000003A8  8B 01		        mov     eax, [ecx].PreInt
 000003AA  C1 E8 0C		        shr     eax, 12
 000003AD  0D 3FF00000		        or      eax, 3FF00000H
 000003B2  89 41 14		        mov     dword ptr [ecx].PreFlt+4, eax
 000003B5  8B C2		        mov     eax, edx               ; return value is premade integer
 000003B7  C3			        ret

				        ; fill buffer with random numbers
 000003B8  53			M520:   push    ebx
 000003B9  56			        push    esi
 000003BA  33 F6		        xor     esi, esi               ; kk
 000003BC  BB 00000634		        mov     ebx, MERS_M*4          ; km
				; change ecx from pointing to CRandomMersenneA to pointing to CRandomMersenneA.MT
 000003C1  81 C1 000000A0	        add     ecx, CRandomMersenneA.MT
				        assume  ecx: ptr dword
				        
				        ; kk loop
 000003C7  8B 04 0E		M530:   mov     eax, [ecx+esi]
 000003CA  8B 54 0E 04		        mov     edx, [ecx+esi+4]
 000003CE  25 80000000		        and     eax, UPPER_MASK
 000003D3  81 E2 7FFFFFFF	        and     edx, LOWER_MASK
 000003D9  0B C2		        or      eax, edx
 000003DB  D1 E8		        shr     eax, 1
 000003DD  1B D2		        sbb     edx, edx
 000003DF  81 E2 9908B0DF	        and     edx, MERS_A
 000003E5  33 C2		        xor     eax, edx
 000003E7  33 04 0B		        xor     eax, [ecx+ebx]
 000003EA  89 04 0E		        mov     [ecx+esi], eax
 000003ED  83 C3 04		        add     ebx, 4
 000003F0  81 FB 000009C0	        cmp     ebx, MERS_N*4
 000003F6  72 07		        jb      short M540
				        ; copy begin of table to after end to simplify kk+1 wraparound
 000003F8  8B 01		        mov     eax, [ecx]
 000003FA  89 04 0B		        mov     [ecx+ebx], eax 
 000003FD  33 DB		        xor     ebx, ebx
 000003FF  83 C6 04		M540:   add     esi, 4
 00000402  81 FE 000009C0	        cmp     esi, MERS_N*4
 00000408  72 BD		        jb      M530                   ; loop end        
				        
				; change ecx back to pointing to CRandomMersenneA
 0000040A  81 E9 000000A0	        sub     ecx, CRandomMersenneA.MT        
				assume  ecx: ptr CRandomMersenneA

 00000410  33 D2		        xor     edx, edx
 00000412  89 91 00000080	        mov     [ecx].MTI, edx
 00000418  5E			        pop     esi
 00000419  5B			        pop     ebx
 0000041A  E9 FFFFFF49		        jmp     M510        
				        
 0000041F			_MersBRandom ENDP

				;  extern "C" double MersRandom(void * Pthis); // Output random float

 0000041F			_MersRandom PROC NEAR                  ; generate random float with 32 bits resolution
 0000041F  8B 4C 24 04		        mov     ecx, [esp+4]           ; Pthis
				assume  ecx: ptr CRandomMersenneA

 00000423  8B 51 40		        mov     edx, [ecx].PreInx      ; index into premade numbers
 00000426  DD 44 51 10		        fld     [ecx+edx*2].PreFlt     ; fetch premade floating point random number
 0000042A  DC 61 70		        fsub    [ecx].one              ; subtract 1.0
 0000042D  E9 FFFFFDA0		        jmp     MersBRandom_reg        ; random bits
 00000432			_MersRandom ENDP


				;  extern "C" int MersIRandom (void * Pthis, int min, int max);  // Output random integer

 00000432			_MersIRandom PROC   NEAR
 00000432  8B 4C 24 04		        mov     ecx, [esp+4]           ; Pthis
				assume  ecx: ptr CRandomMersenneA
 00000436  E8 FFFFFD97		        call    MersBRandom_reg        ; random bits
 0000043B  8B 54 24 0C		        mov     edx, [esp+12]          ; max
 0000043F  8B 4C 24 08		        mov     ecx, [esp+8]           ; min
 00000443  2B D1		        sub     edx, ecx
 00000445  78 09		        js      short M720             ; max < min
 00000447  83 C2 01		        add     edx, 1                 ; max - min + 1
 0000044A  F7 E2		        mul     edx                    ; multiply random number by interval and truncate
 0000044C  8D 04 11		        lea     eax, [edx+ecx]         ; add min
 0000044F  C3			        ret
 00000450  B8 80000000		M720:   mov     eax, 80000000H         ; error exit
 00000455  C3			        ret
 00000456			_MersIRandom ENDP


				;  extern "C" int MersIRandomX (void * Pthis, int min, int max);        // Output random integer

 00000456			_MersIRandomX PROC   NEAR
 00000456  57			        push    edi
 00000457  8B 4C 24 08		        mov     ecx, [esp+8]           ; Pthis
 0000045B  8B 54 24 0C		        mov     edx, [esp+12]          ; min
 0000045F  8B 7C 24 10		        mov     edi, [esp+16]          ; max
				assume  ecx: ptr CRandomMersenneA

 00000463  2B FA		        sub     edi, edx               ; max - min
 00000465  7E 2A		        jle     short M830             ; max <= min (signed)
 00000467  47			        inc     edi                    ; interval = max - min + 1
				        
				        ; if (interval != LastInterval) {
 00000468  3B 79 48		        cmp     edi, [ecx].LastInterval
 0000046B  74 10		        je      M810
				        ; RLimit = uint32(((uint64)1 << 32) / interval) * interval - 1;}
 0000046D  33 C0		        xor     eax, eax               ; 0
 0000046F  8D 50 01		        lea     edx, [eax+1]           ; 1
 00000472  F7 F7		        div     edi                    ; (would give overflow if interval = 1)
 00000474  F7 E7		        mul     edi
 00000476  48			        dec     eax
 00000477  89 41 4C		        mov     [ecx].RLimit, eax
 0000047A  89 79 48		        mov     [ecx].LastInterval, edi
 0000047D			M810:
 0000047D			M820:   ; do { // Rejection loop
 0000047D  E8 FFFFFD50		        call    MersBRandom_reg        ; random bits (ecx is preserved)
				        ; longran  = (uint64)BRandom() * interval;
 00000482  F7 E7		        mul     edi
				        ; } while (remainder > RLimit);
 00000484  3B 41 4C		        cmp     eax, [ecx].RLimit
 00000487  77 F4		        ja      M820
				        
				        ; return (int32)iran + min
 00000489  8B 44 24 0C		        mov     eax, [esp+12]          ; min
 0000048D  03 C2		        add     eax, edx
 0000048F  5F			        pop     edi
 00000490  C3			        ret
				        
 00000491  7C 04		M830:   jl      M840
				        ; max = min. Return min
 00000493  8B C2		        mov     eax, edx
 00000495  5F			        pop     edi
 00000496  C3			        ret                            ; max = min exit
				        
 00000497			M840:   ; max < min: error
 00000497  B8 80000000		        mov     eax, 80000000H         ; error exit
 0000049C  5F			        pop     edi
 0000049D  C3			        ret
 0000049E			_MersIRandomX ENDP


				IFNDEF POSITIONINDEPENDENT
				; -------------------------------------------------------------------------
				;  Single-threaded static link versions for Mersenne Twister
				; -------------------------------------------------------------------------

				;  extern "C" void   MersenneRandomInitByArray(unsigned int seeds[], int length); // Seed by more than 32 bits
 0000049E			_MersenneRandomInitByArray PROC NEAR
 0000049E  53			        push    ebx
 0000049F  56			        push    esi
 000004A0  57			        push    edi
 000004A1  55			        push    ebp
 000004A2  8B 5C 24 14		        mov     ebx, [esp+20]          ; seeds
 000004A6  8B 6C 24 18		        mov     ebp, [esp+24]          ; length
 000004AA  B9 00000000 R	        mov     ecx, offset MersenneInstance
 000004AF  E9 FFFFFC25		        jmp     MersRandomInitByArray_reg     ; jump to function in mersenne32.asm
 000004B4			_MersenneRandomInitByArray ENDP        


				;  extern "C" void   MersenneRandomInit(int seed);  // Re-seed
 000004B4			_MersenneRandomInit PROC NEAR
 000004B4  8B 44 24 04		        mov     eax, [esp+4]           ; seed
 000004B8  B9 00000000 R	        mov     ecx, offset MersenneInstance
 000004BD  E9 FFFFFB46		        jmp     MersRandomInit_reg     ; jump to function in mersenne32.asm
 000004C2			_MersenneRandomInit ENDP


				;  extern "C" double MersenneRandom(); // Output random float
 000004C2			_MersenneRandom PROC NEAR              ; generate random float with 32 bits resolution
 000004C2  B9 00000000 R	        mov     ecx, offset MersenneInstance
				assume  ecx: ptr CRandomMersenneA
 000004C7  8B 51 40		        mov     edx, [ecx].PreInx      ; index into premade numbers
 000004CA  DD 44 51 10		        fld     [ecx+edx*2].PreFlt     ; fetch premade floating point random number
 000004CE  DC 61 70		        fsub    [ecx].one              ; subtract 1.0
 000004D1  E9 FFFFFCFC		        jmp     MersBRandom_reg        ; random bits
 000004D6			_MersenneRandom ENDP


				;  extern "C" int MersenneIRandom (int min, int max); // Output random integer
 000004D6			_MersenneIRandom PROC   NEAR
 000004D6  B9 00000000 R	        mov     ecx, offset MersenneInstance
 000004DB  E8 FFFFFCF2		        call    MersBRandom_reg        ; random bits
 000004E0  8B 54 24 08		        mov     edx, [esp+8]           ; max
 000004E4  8B 4C 24 04		        mov     ecx, [esp+4]           ; min
 000004E8  2B D1		        sub     edx, ecx
 000004EA  78 09		        js      short S410             ; max < min
 000004EC  83 C2 01		        add     edx, 1                 ; max - min + 1
 000004EF  F7 E2		        mul     edx                    ; multiply random number by interval and truncate
 000004F1  8D 04 11		        lea     eax, [edx+ecx]         ; add min
 000004F4  C3			        ret
 000004F5  B8 80000000		S410:   mov     eax, 80000000H         ; error exit
 000004FA  C3			        ret
 000004FB			_MersenneIRandom ENDP


				;  extern "C" int MersenneIRandomX(int min, int max); // Output random integer, exact

 000004FB			_MersenneIRandomX PROC   NEAR
 000004FB  57			        push    edi
 000004FC  B9 00000000 R	        mov     ecx, offset MersenneInstance
 00000501  8B 54 24 08		        mov     edx, [esp+8]           ; min
 00000505  8B 7C 24 0C		        mov     edi, [esp+12]          ; max
				assume  ecx: ptr CRandomMersenneA

 00000509  2B FA		        sub     edi, edx               ; max - min
 0000050B  7E 2A		        jle     short S530             ; max <= min (signed)
 0000050D  47			        inc     edi                    ; interval = max - min + 1
 0000050E  3B 79 48		        cmp     edi, [ecx].LastInterval
 00000511  74 10		        je      S510
 00000513  33 C0		        xor     eax, eax               ; 0
 00000515  8D 50 01		        lea     edx, [eax+1]           ; 1
 00000518  F7 F7		        div     edi                    ; (would give overflow if interval = 1)
 0000051A  F7 E7		        mul     edi
 0000051C  48			        dec     eax
 0000051D  89 41 4C		        mov     [ecx].RLimit, eax
 00000520  89 79 48		        mov     [ecx].LastInterval, edi
 00000523			S510:
 00000523  E8 FFFFFCAA		S520:   call    MersBRandom_reg        ; random bits (ecx is preserved)
 00000528  F7 E7		        mul     edi
 0000052A  3B 41 4C		        cmp     eax, [ecx].RLimit
 0000052D  77 F4		        ja      S520        
 0000052F  8B 44 24 08		        mov     eax, [esp+8]           ; min
 00000533  03 C2		        add     eax, edx
 00000535  5F			        pop     edi
 00000536  C3			        ret     
				        
 00000537  7C 04		S530:   jl      S540
				        ; max = min. Return min
 00000539  8B C2		        mov     eax, edx
 0000053B  5F			        pop     edi
 0000053C  C3			        ret                            ; max = min exit
				        
 0000053D			S540:   ; max < min: error
 0000053D  B8 80000000		        mov     eax, 80000000H         ; error exit
 00000542  5F			        pop     edi
 00000543  C3			        ret     
 00000544			_MersenneIRandomX ENDP


				;  extern "C" unsigned int MersenneBRandom();                   // Output random bits
 00000544			_MersenneBRandom PROC NEAR             ; generate random float with 32 bits resolution
 00000544  B9 00000000 R	        mov     ecx, offset MersenneInstance
				assume  ecx: ptr CRandomMersenneA
 00000549  E9 FFFFFC84		        jmp     MersBRandom_reg        ; random bits
 0000054E			_MersenneBRandom ENDP


				; -----------------------------------------------------------------
				;  Single-threaded DLL versions for Mersenne Twister, Windows only
				; -----------------------------------------------------------------

				;  extern "C" void __stdcall MersenneRandomInitByArrayD(unsigned int seeds[], int length); // Seed by more than 32 bits
 0000054E			_MersenneRandomInitByArrayD@8 PROC NEAR
				        ; translate __cdecl to __stdcall calling
 0000054E  8B 44 24 04		        mov     eax, [esp+4]           ; seeds
 00000552  8B 54 24 08		        mov     edx, [esp+8]           ; length
 00000556  52			        push    edx
 00000557  50			        push    eax
 00000558  E8 FFFFFF41		        call    _MersenneRandomInitByArray
 0000055D  59			        pop     ecx
 0000055E  59			        pop     ecx
 0000055F  C2 0008		        ret     8
 00000562			_MersenneRandomInitByArrayD@8 ENDP        


				;  extern "C" void __stdcall MersenneRandomInitD(int seed); // Re-seed
 00000562			_MersenneRandomInitD@4 PROC NEAR
				        ; remove parameter from stack
 00000562  5A			        pop     edx                    ; return address
 00000563  58			        pop     eax                    ; seed
 00000564  52			        push    edx                    ; put return address back in        
 00000565  B9 00000000 R	        mov     ecx, offset MersenneInstance
				        ; eax = seed, ecx = Pthis
 0000056A  E9 FFFFFA99		        jmp     MersRandomInit_reg     ; jump to function in mersenne32.asm
 0000056F			_MersenneRandomInitD@4 ENDP


				;  extern "C" double __stdcall MersenneRandomD(); // Output random float
 0000056F			_MersenneRandomD@0 PROC NEAR           ; generate random float with 32 bits resolution
 0000056F  B9 00000000 R	        mov     ecx, offset MersenneInstance
				assume  ecx: ptr CRandomMersenneA
 00000574  8B 51 40		        mov     edx, [ecx].PreInx      ; index into premade numbers
 00000577  DD 44 51 10		        fld     [ecx+edx*2].PreFlt     ; fetch premade floating point random number
 0000057B  DC 61 70		        fsub    [ecx].one              ; subtract 1.0
 0000057E  E9 FFFFFC4F		        jmp     MersBRandom_reg        ; random bits
 00000583			_MersenneRandomD@0 ENDP


				;  extern "C" int __stdcall MersenneIRandomD (int min, int max); // Output random integer
 00000583			_MersenneIRandomD@8 PROC   NEAR
 00000583  B9 00000000 R	        mov     ecx, offset MersenneInstance
 00000588  E8 FFFFFC45		        call    MersBRandom_reg        ; random bits
 0000058D  8B 54 24 08		        mov     edx, [esp+8]           ; max
 00000591  8B 4C 24 04		        mov     ecx, [esp+4]           ; min
 00000595  2B D1		        sub     edx, ecx
 00000597  78 0B		        js      short S710             ; max < min
 00000599  83 C2 01		        add     edx, 1                 ; max - min + 1
 0000059C  F7 E2		        mul     edx                    ; multiply random number by interval and truncate
 0000059E  8D 04 11		        lea     eax, [edx+ecx]         ; add min
 000005A1  C2 0008		        ret     8
 000005A4  B8 80000000		S710:   mov     eax, 80000000H         ; error exit
 000005A9  C2 0008		        ret     8
 000005AC			_MersenneIRandomD@8 ENDP


				;  extern "C" int __stdcall MersenneIRandomXD(int min, int max); // Output random integer, exact

 000005AC			_MersenneIRandomXD@8 PROC   NEAR
 000005AC  57			        push    edi
 000005AD  B9 00000000 R	        mov     ecx, offset MersenneInstance
 000005B2  8B 54 24 08		        mov     edx, [esp+8]           ; min
 000005B6  8B 7C 24 0C		        mov     edi, [esp+12]          ; max
				assume  ecx: ptr CRandomMersenneA

 000005BA  2B FA		        sub     edi, edx               ; max - min
 000005BC  7E 2C		        jle     short S830             ; max <= min (signed)
 000005BE  47			        inc     edi                    ; interval = max - min + 1
 000005BF  3B 79 48		        cmp     edi, [ecx].LastInterval
 000005C2  74 10		        je      S810
 000005C4  33 C0		        xor     eax, eax               ; 0
 000005C6  8D 50 01		        lea     edx, [eax+1]           ; 1
 000005C9  F7 F7		        div     edi                    ; (would give overflow if interval = 1)
 000005CB  F7 E7		        mul     edi
 000005CD  48			        dec     eax
 000005CE  89 41 4C		        mov     [ecx].RLimit, eax
 000005D1  89 79 48		        mov     [ecx].LastInterval, edi
 000005D4			S810:
 000005D4  E8 FFFFFBF9		S820:   call    MersBRandom_reg        ; random bits (ecx is preserved)
 000005D9  F7 E7		        mul     edi
 000005DB  3B 41 4C		        cmp     eax, [ecx].RLimit
 000005DE  77 F4		        ja      S820        
 000005E0  8B 44 24 08		        mov     eax, [esp+8]           ; min
 000005E4  03 C2		        add     eax, edx
 000005E6  5F			        pop     edi
 000005E7  C2 0008		        ret     8
				        
 000005EA  7C 06		S830:   jl      S840
				        ; max = min. Return min
 000005EC  8B C2		        mov     eax, edx
 000005EE  5F			        pop     edi
 000005EF  C2 0008		        ret     8                      ; max = min exit
				        
 000005F2			S840:   ; max < min: error
 000005F2  B8 80000000		        mov     eax, 80000000H         ; error exit
 000005F7  5F			        pop     edi
 000005F8  C2 0008		        ret     8
 000005FB			_MersenneIRandomXD@8 ENDP


				;  extern "C" unsigned int __stdcall MersenneBRandomD(); // Output random bits
 000005FB			_MersenneBRandomD@0 PROC NEAR          ; generate random float with 32 bits resolution
 000005FB  B9 00000000 R	        mov     ecx, offset MersenneInstance
				assume  ecx: ptr CRandomMersenneA
 00000600  E9 FFFFFBCD		        jmp     MersBRandom_reg        ; random bits
 00000605			_MersenneBRandomD@0 ENDP

				ENDIF  ; not POSITIONINDEPENDENT

				END
Microsoft (R) Macro Assembler Version 9.00.21022.08	    08/06/09 23:17:55
mersenne32.asm						     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CRandomMersenneA . . . . . . . .	 00000A70
  PreInt . . . . . . . . . . . .	 00000000	 DWord
  PreFlt . . . . . . . . . . . .	 00000010	 QWord
  TmpFlt . . . . . . . . . . . .	 00000038	 QWord
  PreInx . . . . . . . . . . . .	 00000040	 DWord
  Instset  . . . . . . . . . . .	 00000044	 DWord
  LastInterval . . . . . . . . .	 00000048	 DWord
  RLimit . . . . . . . . . . . .	 0000004C	 DWord
  TMB  . . . . . . . . . . . . .	 00000050	 DWord
  TMC  . . . . . . . . . . . . .	 00000060	 DWord
  one  . . . . . . . . . . . . .	 00000070	 QWord
  MTI  . . . . . . . . . . . . .	 00000080	 DWord
  UMASK  . . . . . . . . . . . .	 00000084	 DWord
  LMASK  . . . . . . . . . . . .	 00000088	 DWord
  MATA . . . . . . . . . . . . .	 0000008C	 DWord
  wrap1  . . . . . . . . . . . .	 00000090	 DWord
  MT . . . . . . . . . . . . . .	 000000A0	 DWord
  wrap2  . . . . . . . . . . . .	 00000A60	 DWord
CRandomMotherA . . . . . . . . .	 00000040
  one  . . . . . . . . . . . . .	 00000000	 QWord
  Instset  . . . . . . . . . . .	 00000008	 DWord
  M4 . . . . . . . . . . . . . .	 0000000C	 DWord
  M3 . . . . . . . . . . . . . .	 00000010	 DWord
  M2 . . . . . . . . . . . . . .	 00000014	 DWord
  M1 . . . . . . . . . . . . . .	 00000018	 DWord
  M0 . . . . . . . . . . . . . .	 0000001C	 DWord
  MC . . . . . . . . . . . . . .	 00000020	 DWord
  zero . . . . . . . . . . . . .	 00000024	 DWord
  RanP1  . . . . . . . . . . . .	 00000028	 QWord
  MF3  . . . . . . . . . . . . .	 00000030	 DWord
  MF2  . . . . . . . . . . . . .	 00000034	 DWord
  MF1  . . . . . . . . . . . . .	 00000038	 DWord
  MF0  . . . . . . . . . . . . .	 0000003C	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 00000A70 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000605 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

Mers_init0 . . . . . . . . . . .	P Near	 0000002D _TEXT	Length= 0000009C Public
  M210 . . . . . . . . . . . . .	L Near	 0000009D _TEXT	
_MersBRandom . . . . . . . . . .	P Near	 000001CE _TEXT	Length= 00000251 Public
  M420 . . . . . . . . . . . . .	L Near	 00000286 _TEXT	
  M430 . . . . . . . . . . . . .	L Near	 000002BB _TEXT	
  M440 . . . . . . . . . . . . .	L Near	 00000348 _TEXT	
  M510 . . . . . . . . . . . . .	L Near	 00000368 _TEXT	
  M520 . . . . . . . . . . . . .	L Near	 000003B8 _TEXT	
  M530 . . . . . . . . . . . . .	L Near	 000003C7 _TEXT	
  M540 . . . . . . . . . . . . .	L Near	 000003FF _TEXT	
_MersIRandomX  . . . . . . . . .	P Near	 00000456 _TEXT	Length= 00000048 Public
  M810 . . . . . . . . . . . . .	L Near	 0000047D _TEXT	
  M820 . . . . . . . . . . . . .	L Near	 0000047D _TEXT	
  M830 . . . . . . . . . . . . .	L Near	 00000491 _TEXT	
  M840 . . . . . . . . . . . . .	L Near	 00000497 _TEXT	
_MersIRandom . . . . . . . . . .	P Near	 00000432 _TEXT	Length= 00000024 Public
  M720 . . . . . . . . . . . . .	L Near	 00000450 _TEXT	
_MersRandomInitByArray . . . . .	P Near	 000000C9 _TEXT	Length= 00000105 Public
  M310 . . . . . . . . . . . . .	L Near	 000000FE _TEXT	
  M320 . . . . . . . . . . . . .	L Near	 000000FE _TEXT	
  M330 . . . . . . . . . . . . .	L Near	 00000140 _TEXT	
  M340 . . . . . . . . . . . . .	L Near	 00000147 _TEXT	
  M350 . . . . . . . . . . . . .	L Near	 0000014A _TEXT	
  M360 . . . . . . . . . . . . .	L Near	 0000014F _TEXT	
  M370 . . . . . . . . . . . . .	L Near	 0000018D _TEXT	
  M380 . . . . . . . . . . . . .	L Near	 0000019A _TEXT	
  M390 . . . . . . . . . . . . .	L Near	 000001C0 _TEXT	
  M391 . . . . . . . . . . . . .	L Near	 000001C0 _TEXT	
_MersRandomInit  . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000002D Public
  M110 . . . . . . . . . . . . .	L Near	 00000023 _TEXT	
  M120 . . . . . . . . . . . . .	L Near	 00000023 _TEXT	
_MersRandom  . . . . . . . . . .	P Near	 0000041F _TEXT	Length= 00000013 Public
_MersenneBRandomD@0  . . . . . .	P Near	 000005FB _TEXT	Length= 0000000A Public
_MersenneBRandom . . . . . . . .	P Near	 00000544 _TEXT	Length= 0000000A Public
_MersenneIRandomD@8  . . . . . .	P Near	 00000583 _TEXT	Length= 00000029 Public
  S710 . . . . . . . . . . . . .	L Near	 000005A4 _TEXT	
_MersenneIRandomXD@8 . . . . . .	P Near	 000005AC _TEXT	Length= 0000004F Public
  S810 . . . . . . . . . . . . .	L Near	 000005D4 _TEXT	
  S820 . . . . . . . . . . . . .	L Near	 000005D4 _TEXT	
  S830 . . . . . . . . . . . . .	L Near	 000005EA _TEXT	
  S840 . . . . . . . . . . . . .	L Near	 000005F2 _TEXT	
_MersenneIRandomX  . . . . . . .	P Near	 000004FB _TEXT	Length= 00000049 Public
  S510 . . . . . . . . . . . . .	L Near	 00000523 _TEXT	
  S520 . . . . . . . . . . . . .	L Near	 00000523 _TEXT	
  S530 . . . . . . . . . . . . .	L Near	 00000537 _TEXT	
  S540 . . . . . . . . . . . . .	L Near	 0000053D _TEXT	
_MersenneIRandom . . . . . . . .	P Near	 000004D6 _TEXT	Length= 00000025 Public
  S410 . . . . . . . . . . . . .	L Near	 000004F5 _TEXT	
_MersenneRandomD@0 . . . . . . .	P Near	 0000056F _TEXT	Length= 00000014 Public
_MersenneRandomInitByArrayD@8  .	P Near	 0000054E _TEXT	Length= 00000014 Public
_MersenneRandomInitByArray . . .	P Near	 0000049E _TEXT	Length= 00000016 Public
_MersenneRandomInitD@4 . . . . .	P Near	 00000562 _TEXT	Length= 0000000D Public
_MersenneRandomInit  . . . . . .	P Near	 000004B4 _TEXT	Length= 0000000E Public
_MersenneRandom  . . . . . . . .	P Near	 000004C2 _TEXT	Length= 00000014 Public


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
LOWER_MASK . . . . . . . . . . .	Number	 7FFFFFFFh   
M410 . . . . . . . . . . . . . .	L Near	 000001EE _TEXT	
M500 . . . . . . . . . . . . . .	L Near	 0000035A _TEXT	
MERS_A . . . . . . . . . . . . .	Number	 9908B0DFh   
MERS_B . . . . . . . . . . . . .	Number	 9D2C5680h   
MERS_C . . . . . . . . . . . . .	Number	 EFC60000h   
MERS_L . . . . . . . . . . . . .	Number	 00000012h   
MERS_M . . . . . . . . . . . . .	Number	 0000018Dh   
MERS_N . . . . . . . . . . . . .	Number	 00000270h   
MERS_R . . . . . . . . . . . . .	Number	 0000001Fh   
MERS_S . . . . . . . . . . . . .	Number	 00000007h   
MERS_T . . . . . . . . . . . . .	Number	 0000000Fh   
MERS_U . . . . . . . . . . . . .	Number	 0000000Bh   
MersBRandom_reg  . . . . . . . .	L Near	 000001D2 _TEXT	
MersRandomInitByArray_reg  . . .	L Near	 000000D9 _TEXT	
MersRandomInit_reg . . . . . . .	L Near	 00000008 _TEXT	
MersenneInstance . . . . . . . .	CRandomMersenneA  00000000 _DATA	
PREMADELOST  . . . . . . . . . .	Number	 00000004h   
TEMPERING  . . . . . . . . . . .	Number	 00000001h   
UPPER_MASK . . . . . . . . . . .	Number	 -80000000h   
_InstructionSet  . . . . . . . .	L Near	 00000000 FLAT	External

	   0 Warnings
	   0 Errors
