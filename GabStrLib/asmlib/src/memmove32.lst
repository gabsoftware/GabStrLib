Microsoft (R) Macro Assembler Version 9.00.21022.08	    08/06/09 23:17:55
memmove32.asm						     Page 1 - 1


				;*************************  memmove32.asm  ***********************************
				; Author:           Agner Fog
				; Date created:     2008-07-18
				; Last modified:    2008-07-18
				; Description:
				; Faster version of the standard memmove function:
				; void * A_memmove(void *dest, const void *src, size_t count);
				; Moves 'count' bytes from 'src' to 'dest'. src and dest may overlap.
				;
				; Overriding standard function memmove:
				; The alias ?OVR_memmove is changed to _memmove in the object file if
				; it is desired to override the standard library function memmove.
				;
				; Position-independent code is generated if POSITIONINDEPENDENT is defined.
				;
				; Optimization:
				; Uses XMM registers to copy 16 bytes at a time, aligned.
				; If source and destination are misaligned relative to each other
				; then the code will combine parts of every two consecutive 16-bytes 
				; blocks from the source into one 16-bytes register which is written 
				; to the destination, aligned.
				; This method is 2 - 6 times faster than the implementations in the
				; standard C libraries (MS, Gnu) when src or dest are misaligned.
				; When src and dest are aligned by 16 (relative to each other) then this
				; function is only slightly faster than the best standard libraries.
				; CPU dispatching included for 386, SSE2 and Suppl-SSE3 instruction sets.
				;
				; Copyright (c) 2008 GNU General Public License www.gnu.org/licenses/gpl.html
				;******************************************************************************
				.686
				.xmm
				.model flat

				public _A_memmove                      ; Function A_memmove
				public ?OVR_memmove                    ; ?OVR removed if standard function memmove overridden

				; Imported from memcpy32.asm:
				extern _CacheBypassLimit: dword        ; Bypass cache if count > _CacheBypassLimit
				extern $memcpyEntry2: near             ; Function entry from memmove

				; Imported from instrset32.asm
				extern _InstructionSet: near           ; Instruction set for CPU dispatcher

				; Define return from this function
				RETURNM MACRO
				IFDEF   POSITIONINDEPENDENT
				        pop     ebx
				ENDIF
				        pop     edi
				        pop     esi
				        mov     eax, [esp+4]           ; Return value = dest
				        ret
				ENDM

				; Macro for arbitrary instruction with position-independent reference
				PICREFERENCE MACRO TARGET, REFPOINT, BYTE1, BYTE2, BYTE3
				; Make position-independent instrution of the form
				; add eax, [ebx+TARGET-REFPOINT]
				; where ebx contains the address of REFPOINT
				; BYTE1, BYTE2, BYTE3 are the first 2 or 3 bytes of the instruction
				; add eax, [ebx+????]
				; (as obtained from an assembly listing) including opcode byte, 
				; mod/reg/rm byte and possibly sib byte, but not including the 4-bytes 
				; offset which is generated by this macro.
				; Any instruction and any registers can be coded into BYTE1, BYTE2, BYTE3.

				local p0, p1, p2
				; Insert byte codes except last one
				p0:
				   db  BYTE1
				IFNB  <BYTE3>      ; if BYTE3 not blank
				   db  BYTE2
				ENDIF   
				p1:   
				; Make bogus CALL instruction for making self-relative reference.
				; This is the only way the assembler can make a self-relative reference
				   call near ptr TARGET + (p2-REFPOINT) 
				p2:
				; back-patch CALL instruction to change it to the desired instruction
				; by replacing CALL opcode by the last byte of desired instruction
				   org p1
				IFNB  <BYTE3>      ; if BYTE3 not blank
				   db  BYTE3
				ELSE
				   db  BYTE2
				ENDIF
				   org p2          ; Back to end of instruction
				ENDM 


 00000000			.code

				; extern "C" void * A_memmove(void * dest, const void * src, size_t count);
				; Function entry:
 00000000			_A_memmove PROC   NEAR
 00000000			?OVR_memmove LABEL NEAR
 00000000  56			        push    esi
 00000001  57			        push    edi
 00000002  8B 7C 24 0C		        mov     edi, [esp+12]          ; dest
 00000006  8B 74 24 10		        mov     esi, [esp+16]          ; src
 0000000A  8B 4C 24 14		        mov     ecx, [esp+20]          ; count
				        
				        ; Check if dest overlaps src
 0000000E  8B C7		        mov     eax, edi
 00000010  2B C6		        sub     eax, esi
 00000012  3B C1		        cmp     eax, ecx
				        ; We can avoid testing for dest < src by using unsigned compare:
				        ; Must move backwards if unsigned(dest-src) < count
 00000014  0F 83 00000000 E	        jae     $memcpyEntry2          ; Jump to memcpy if we can move forwards
				        
				        ; Cannot use memcpy. Must move backwards because of overlap between src and dest
				        
				IFNDEF  POSITIONINDEPENDENT
 0000001A  FF 25 000000C0 R	        jmp     [memmoveDispatch]      ; Go to appropriate version, depending on instruction set
 = 00000000			RP      equ     0                      ; RP = 0 if not position-independent

				ELSE    ; Position-independent code
				ENDIF        
				        
 00000020			memmoveSSE2: ; SSE2 and later versions begin here
				        
 00000020  83 F9 40		        cmp     ecx, 40H
 00000023  0F 83 000000A9	        jae     B100                    ; Use simpler code if count < 64
				        
				        ; count < 64. Move 32-16-8-4-2-1 bytes
 00000029  F7 C1 00000020	        test    ecx, 20H
 0000002F  74 31		        jz      A100
				        ; move 32 bytes
				        ; movq is faster than movdqu on current processors,
				        ; movdqu may be faster on future processors
 00000031  83 E9 20		        sub     ecx, 20H
 00000034  F3/ 0F 7E 44 31	        movq    xmm0, qword ptr [esi+ecx+18H]
	   18
 0000003A  F3/ 0F 7E 4C 31	        movq    xmm1, qword ptr [esi+ecx+10H]
	   10
 00000040  F3/ 0F 7E 54 31	        movq    xmm2, qword ptr [esi+ecx+8]
	   08
 00000046  F3/ 0F 7E 1C 31	        movq    xmm3, qword ptr [esi+ecx]
 0000004B  66| 0F D6 44 39	        movq    qword ptr [edi+ecx+18H], xmm0
	   18
 00000051  66| 0F D6 4C 39	        movq    qword ptr [edi+ecx+10H], xmm1
	   10
 00000057  66| 0F D6 54 39	        movq    qword ptr [edi+ecx+8], xmm2
	   08
 0000005D  66| 0F D6 1C 39	        movq    qword ptr [edi+ecx], xmm3
 00000062  F7 C1 00000010	A100:   test    ecx, 10H
 00000068  74 19		        jz      A200
				        ; move 16 bytes
 0000006A  83 E9 10		        sub     ecx, 10H
 0000006D  F3/ 0F 7E 44 31	        movq    xmm0, qword ptr [esi+ecx+8]
	   08
 00000073  F3/ 0F 7E 0C 31	        movq    xmm1, qword ptr [esi+ecx]
 00000078  66| 0F D6 44 39	        movq    qword ptr [edi+ecx+8], xmm0
	   08
 0000007E  66| 0F D6 0C 39	        movq    qword ptr [edi+ecx], xmm1
 00000083  F7 C1 00000008	A200:   test    ecx, 8
 00000089  74 0D		        jz      A300
				        ; move 8 bytes
 0000008B  83 E9 08		        sub     ecx, 8
 0000008E  F3/ 0F 7E 04 31	        movq    xmm0, qword ptr [esi+ecx]
 00000093  66| 0F D6 04 39	        movq    qword ptr [edi+ecx], xmm0
 00000098  F7 C1 00000004	A300:   test    ecx, 4
 0000009E  74 0B		        jz      A400
				        ; move 4 bytes
 000000A0  83 E9 04		        sub     ecx, 4
 000000A3  8B 04 31		        mov     eax, [esi+ecx]
 000000A6  89 04 39		        mov     [edi+ecx], eax
 000000A9  74 20		        jz      A900                     ; early out if count divisible by 4
 000000AB  F7 C1 00000002	A400:   test    ecx, 2
 000000B1  74 0B		        jz      A500
				        ; move 2 bytes
 000000B3  83 E9 02		        sub     ecx, 2
 000000B6  0F B7 04 31		        movzx   eax, word ptr [esi+ecx]
 000000BA  66| 89 04 39		        mov     [edi+ecx], ax
 000000BE  F7 C1 00000001	A500:   test    ecx, 1
 000000C4  74 05		        jz      A900
				        ; move 1 byte
 000000C6  0F B6 06		        movzx   eax, byte ptr [esi]
 000000C9  88 07		        mov     [edi], al
 000000CB			A900:   ; finished
				        RETURNM
 000000CB  5F		     1	        pop     edi
 000000CC  5E		     1	        pop     esi
 000000CD  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 000000D1  C3		     1	        ret
				        
 000000D2			B100:   ; count >= 64
				        ; Note: this part will not always work if count < 64
				        ; Calculate size of last block after last regular boundary of dest
 000000D2  8D 14 39		        lea     edx, [edi+ecx]         ; end of dext
 000000D5  83 E2 0F		        and     edx, 0FH
 000000D8  74 49		        jz      B300                   ; Skip if end of dest aligned by 16
				        
				        ; edx = size of last partial block, 1 - 15 bytes
 000000DA  F7 C2 00000008	        test    edx, 8
 000000E0  74 0D		        jz      B200
				        ; move 8 bytes
 000000E2  83 E9 08		        sub     ecx, 8
 000000E5  F3/ 0F 7E 04 31	        movq    xmm0, qword ptr [esi+ecx]
 000000EA  66| 0F D6 04 39	        movq    qword ptr [edi+ecx], xmm0
 000000EF  F7 C2 00000004	B200:   test    edx, 4
 000000F5  74 09		        jz      B210
				        ; move 4 bytes
 000000F7  83 E9 04		        sub     ecx, 4
 000000FA  8B 04 31		        mov     eax, [esi+ecx]
 000000FD  89 04 39		        mov     [edi+ecx], eax
 00000100  F7 C2 00000002	B210:   test    edx, 2
 00000106  74 0B		        jz      B220
				        ; move 2 bytes
 00000108  83 E9 02		        sub     ecx, 2
 0000010B  0F B7 04 31		        movzx   eax, word ptr [esi+ecx]
 0000010F  66| 89 04 39		        mov     [edi+ecx], ax
 00000113  F7 C2 00000001	B220:   test    edx, 1
 00000119  74 08		        jz      B300
				        ; move 1 byte
 0000011B  49			        dec     ecx
 0000011C  0F B6 04 31		        movzx   eax, byte ptr [esi+ecx]
 00000120  88 04 39		        mov     [edi+ecx], al
				        
 00000123			B300:   ; Now end of dest is aligned by 16. Any partial block has been moved        
				        ; Find alignment of end of src modulo 16 at this point:
 00000123  8D 04 31		        lea     eax, [esi+ecx]
 00000126  83 E0 0F		        and     eax, 0FH
				        
				        ; Set up for loop moving 32 bytes per iteration:
 00000129  8B D1		        mov     edx, ecx               ; Save count
 0000012B  83 E1 E0		        and     ecx, -20H              ; Round down to nearest multiple of 32
 0000012E  2B D1		        sub     edx, ecx               ; Remaining data after loop
 00000130  2B F0		        sub     esi, eax               ; Nearest preceding aligned block of src
				        ; Add the same to esi and edi as we have subtracted from ecx
 00000132  03 F2		        add     esi, edx
 00000134  03 FA		        add     edi, edx
				        
				IFNDEF  POSITIONINDEPENDENT
				        ; Check if count very big
 00000136  3B 0D 00000000 E	        cmp     ecx, [_CacheBypassLimit]
 0000013C  77 07		        ja      B400                   ; Use non-temporal store if count > _CacheBypassLimit
				        
				        ; Dispatch to different codes depending on src alignment
 0000013E  FF 24 85		        jmp     MAlignmentDispatch[eax*4]
	   00000000 R

 00000145			B400:   ; Dispatch to different codes depending on src alignment
 00000145  FF 24 85		        jmp     MAlignmentDispatchNT[eax*4]
	   00000080 R

				ELSE    ; Position-independent code
				ENDIF

				align   16
 00000150			C100:   ; Code for aligned src. SSE2 or later instruction set
				        ; The nice case, src and dest have same alignment.

				        ; Loop. ecx has positive index from the beginning, counting down to zero
 00000150  83 E9 20		        sub     ecx, 20H
 00000153  0F 28 44 31 10	        movaps  xmm0, [esi+ecx+10H]
 00000158  0F 28 0C 31		        movaps  xmm1, [esi+ecx]
 0000015C  0F 29 44 39 10	        movaps  [edi+ecx+10H], xmm0
 00000161  0F 29 0C 39		        movaps  [edi+ecx], xmm1
 00000165  75 E9		        jnz     C100
				        
				        ; Move the remaining edx bytes (0 - 31):
				        ; move 16-8-4-2-1 bytes, aligned
 00000167  85 D2		        test    edx, edx
 00000169  74 62		        jz      C500                   ; Early out if no more data
 0000016B  F7 C2 00000010	        test    edx, 10H
 00000171  74 0B		        jz      C200
				        ; move 16 bytes
 00000173  83 E9 10		        sub     ecx, 10H
 00000176  0F 28 04 31		        movaps  xmm0, [esi+ecx]
 0000017A  0F 29 04 39		        movaps  [edi+ecx], xmm0
 0000017E			C200:   ; Other branches come in here
 0000017E  85 D2		        test    edx, edx
 00000180  74 4B		        jz      C500                   ; Early out if no more data
 00000182  F7 C2 00000008	        test    edx, 8
 00000188  74 0D		        jz      C210        
				        ; move 8 bytes
 0000018A  83 E9 08		        sub     ecx, 8 
 0000018D  F3/ 0F 7E 04 31	        movq    xmm0, qword ptr [esi+ecx]
 00000192  66| 0F D6 04 39	        movq    qword ptr [edi+ecx], xmm0
 00000197  F7 C2 00000004	C210:   test    edx, 4
 0000019D  74 0B		        jz      C220        
				        ; move 4 bytes
 0000019F  83 E9 04		        sub     ecx, 4        
 000001A2  8B 04 31		        mov     eax, [esi+ecx]
 000001A5  89 04 39		        mov     [edi+ecx], eax
 000001A8  74 23		        jz      C500                   ; Early out if count divisible by 4
 000001AA  F7 C2 00000002	C220:   test    edx, 2
 000001B0  74 0B		        jz      C230        
				        ; move 2 bytes
 000001B2  83 E9 02		        sub     ecx, 2
 000001B5  0F B7 04 31		        movzx   eax, word ptr [esi+ecx]
 000001B9  66| 89 04 39		        mov     [edi+ecx], ax
 000001BD  F7 C2 00000001	C230:   test    edx, 1
 000001C3  74 08		        jz      C500        
				        ; move 1 byte
 000001C5  49			        dec     ecx
 000001C6  0F B6 04 31		        movzx   eax, byte ptr [esi+ecx]
 000001CA  88 04 39		        mov     [edi+ecx], al
 000001CD			C500:   ; finished     
				        RETURNM
 000001CD  5F		     1	        pop     edi
 000001CE  5E		     1	        pop     esi
 000001CF  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 000001D3  C3		     1	        ret
				        
				; Code for each src alignment, SSE2 instruction set:
				; Make separate code for each alignment u because the shift instructions
				; have the shift count as a constant:

				MOVE_REVERSE_UNALIGNED_SSE2 MACRO u, nt
				; Move ecx + edx bytes of data
				; Source is misaligned. (src-dest) modulo 16 = u
				; nt = 1 if non-temporal store desired
				; eax = u
				; esi = src - u = nearest preceding 16-bytes boundary
				; edi = dest (aligned)
				; ecx = count rounded down to nearest divisible by 32
				; edx = remaining bytes to move after loop
				LOCAL L1, L2
				        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
				L1:     ; Loop. ecx has positive index from the beginning, counting down to zero
				        sub     ecx, 20H
				        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        movdqa  xmm2, [esi+ecx]
				        movdqa  xmm3, xmm1             ; Copy because used twice
				        pslldq  xmm0, 16-u             ; shift left
				        psrldq  xmm1, u                ; shift right
				        por     xmm0, xmm1             ; combine blocks
				        IF nt eq 0
				        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
				        ELSE
				        movntdq [edi+ecx+10H], xmm0    ; Save aligned
				        ENDIF
				        movdqa  xmm0, xmm2             ; Save for next iteration
				        pslldq  xmm3, 16-u             ; shift left
				        psrldq  xmm2, u                ; shift right
				        por     xmm3, xmm2             ; combine blocks
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm3        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm3        ; Save aligned
				        ENDIF
				        jnz     L1
				                
				        ; Move edx remaining bytes
				        test    edx, 10H
				        jz      L2
				        ; One more 16-bytes block to move
				        sub     ecx, 10H
				        movdqa  xmm1, [esi+ecx]
				        pslldq  xmm0, 16-u             ; shift left
				        psrldq  xmm1, u                ; shift right
				        por     xmm0, xmm1             ; combine blocks
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm0        ; Save aligned
				        ENDIF        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM       

				MOVE_REVERSE_UNALIGNED_SSE2_4 MACRO nt
				; Special case: u = 4
				LOCAL L1, L2
				        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
				L1:     ; Loop. ecx has positive index from the beginning, counting down to zero
				        sub     ecx, 20H
				        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        movdqa  xmm2, [esi+ecx]
				        movdqa  xmm3, xmm0
				        movdqa  xmm0, xmm2        
				        movss   xmm2, xmm1
				        pshufd  xmm2, xmm2, 00111001B  ; Rotate right
				        movss   xmm1, xmm3
				        pshufd  xmm1, xmm1, 00111001B  ; Rotate right
				        IF nt eq 0
				        movdqa  [edi+ecx+10H], xmm1    ; Save aligned
				        movdqa  [edi+ecx], xmm2        ; Save aligned
				        ELSE
				        movntdq [edi+ecx+10H], xmm1    ; Non-temporal save
				        movntdq [edi+ecx], xmm2        ; Non-temporal save
				        ENDIF
				        jnz     L1
				                
				        ; Move edx remaining bytes
				        test    edx, 10H
				        jz      L2
				        ; One more 16-bytes block to move
				        sub     ecx, 10H
				        movdqa  xmm1, [esi+ecx]
				        movss   xmm1, xmm0
				        pshufd  xmm1, xmm1, 00111001B  ; Rotate right
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm1        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm1        ; Non-temporal save
				        ENDIF        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM       

				MOVE_REVERSE_UNALIGNED_SSE2_8 MACRO nt
				; Special case: u = 8
				LOCAL L1, L2
				        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
				        shufps  xmm0, xmm0, 01001110B  ; Rotate
				L1:     ; Loop. ecx has positive index from the beginning, counting down to zero
				        sub     ecx, 20H
				        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        shufps  xmm1, xmm1, 01001110B  ; Rotate
				        movsd   xmm0, xmm1
				        IF nt eq 0
				        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
				        ELSE
				        movntdq [edi+ecx+10H], xmm0    ; Non-temporal save
				        ENDIF
				        movdqa  xmm0, [esi+ecx]
				        shufps  xmm0, xmm0, 01001110B  ; Rotate
				        movsd   xmm1, xmm0
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm1        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm1        ; Non-temporal save
				        ENDIF
				        jnz     L1
				                
				        ; Move edx remaining bytes
				        test    edx, 10H
				        jz      L2
				        ; One more 16-bytes block to move
				        sub     ecx, 10H
				        movdqa  xmm1, [esi+ecx]
				        shufps  xmm1, xmm1, 01001110B  ; Rotate 
				        movsd   xmm0, xmm1
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm0        ; Non-temporal save
				        ENDIF        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM       

				MOVE_REVERSE_UNALIGNED_SSE2_12 MACRO nt
				; Special case: u = 12
				LOCAL L1, L2
				        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
				        pshufd  xmm0, xmm0, 10010011B  ; Rotate right
				L1:     ; Loop. ecx has positive index from the beginning, counting down to zero
				        sub     ecx, 20H
				        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        pshufd  xmm1, xmm1, 10010011B  ; Rotate left
				        movss   xmm0, xmm1
				        IF nt eq 0
				        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
				        ELSE
				        movntdq [edi+ecx+10H], xmm0    ; Non-temporal save
				        ENDIF
				        movdqa  xmm0, [esi+ecx]
				        pshufd  xmm0, xmm0, 10010011B  ; Rotate left
				        movss   xmm1, xmm0
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm1        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm1        ; Non-temporal save
				        ENDIF
				        jnz     L1
				                
				        ; Move edx remaining bytes
				        test    edx, 10H
				        jz      L2
				        ; One more 16-bytes block to move
				        sub     ecx, 10H
				        movdqa  xmm1, [esi+ecx]
				        pshufd  xmm1, xmm1, 10010011B  ; Rotate left
				        movss   xmm0, xmm1
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm0        ; Non-temporal save
				        ENDIF        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM       

				; Code for each src alignment, Suppl.SSE3 instruction set:
				; Code for unaligned src, Suppl.SSE3 instruction set.
				; Make separate code for each alignment u because the palignr instruction
				; has the shift count as a constant:

				MOVE_REVERSE_UNALIGNED_SSSE3 MACRO u
				; Move ecx + edx bytes of data
				; Source is misaligned. (src-dest) modulo 16 = u
				; eax = u
				; esi = src - u = nearest preceding 16-bytes boundary
				; edi = dest (aligned)
				; ecx = - (count rounded down to nearest divisible by 32)
				; edx = remaining bytes to move after loop
				LOCAL L1, L2
				        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
				        
				L1:     ; Loop. ecx has positive index from the beginning, counting down to zero
				        sub     ecx, 20H
				        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
				        palignr xmm0, xmm1, u          ; Combine parts into aligned block
				        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
				        movdqa  xmm0, [esi+ecx]
				        palignr xmm1, xmm0, u          ; Combine parts into aligned block
				        movdqa  [edi+ecx], xmm1        ; Save aligned
				        jnz     L1
				        
				        ; Set up for edx remaining bytes
				        test    edx, 10H
				        jz      L2
				        ; One more 16-bytes block to move
				        sub     ecx, 10H
				        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
				        palignr xmm0, xmm1, u          ; Combine parts into aligned block
				        movdqa  [edi+ecx], xmm0        ; Save aligned
				        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes
				        jmp     C200
				ENDM        

				; Make 15 instances of SSE2 macro for each value of the alignment u.
				; These are pointed to by the jump table MAlignmentDispatchSSE2 below
				; (aligns and dummy instructions are inserted manually to minimize the 
				;  number of 16-bytes boundaries inside loops)

 000001D4			D104:   MOVE_REVERSE_UNALIGNED_SSE2_4    0
 000001D4  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 000001D9		     1	??0000:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000001D9  83 E9 20	     1	        sub     ecx, 20H
 000001DC  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000001E2  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000001E7  66| 0F 6F D8	     1	        movdqa  xmm3, xmm0
 000001EB  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2        
 000001EF  F3/ 0F 10 D1	     1	        movss   xmm2, xmm1
 000001F3  66| 0F 70 D2	     1	        pshufd  xmm2, xmm2, 00111001B  ; Rotate right
	   39
 000001F8  F3/ 0F 10 CB	     1	        movss   xmm1, xmm3
 000001FC  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 00111001B  ; Rotate right
	   39
 00000201  66| 0F 7F 4C 39   1	        movdqa  [edi+ecx+10H], xmm1    ; Save aligned
	   10
 00000207  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 0000020C  75 CB	     1	        jnz     ??0000
 0000020E  F7 C2 00000010    1	        test    edx, 10H
 00000214  74 16	     1	        jz      ??0001
 00000216  83 E9 10	     1	        sub     ecx, 10H
 00000219  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000021E  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0
 00000222  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 00111001B  ; Rotate right
	   39
 00000227  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 0000022C		     1	??0001:     ; Get src pointer back to misaligned state
 0000022C  03 F0	     1	        add     esi, eax
 0000022E  E9 FFFFFF4B	     1	        jmp     C200
 00000233  8B C0		mov eax,eax
 00000235  8B C0		mov eax,eax
 00000237			D108:   MOVE_REVERSE_UNALIGNED_SSE2_8    0
 00000237  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 0000023C  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B  ; Rotate
 00000240		     1	??0002:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000240  83 E9 20	     1	        sub     ecx, 20H
 00000243  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000249  0F C6 C9 4E	     1	        shufps  xmm1, xmm1, 01001110B  ; Rotate
 0000024D  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1
 00000251  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000257  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 0000025C  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B  ; Rotate
 00000260  F2/ 0F 10 C8	     1	        movsd   xmm1, xmm0
 00000264  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000269  75 D5	     1	        jnz     ??0002
 0000026B  F7 C2 00000010    1	        test    edx, 10H
 00000271  74 15	     1	        jz      ??0003
 00000273  83 E9 10	     1	        sub     ecx, 10H
 00000276  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000027B  0F C6 C9 4E	     1	        shufps  xmm1, xmm1, 01001110B  ; Rotate 
 0000027F  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1
 00000283  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000288		     1	??0003:     ; Get src pointer back to misaligned state
 00000288  03 F0	     1	        add     esi, eax
 0000028A  E9 FFFFFEEF	     1	        jmp     C200
 0000028F			D10C:   MOVE_REVERSE_UNALIGNED_SSE2_12   0
 0000028F  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000294  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 10010011B  ; Rotate right
	   93
 00000299		     1	??0004:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000299  83 E9 20	     1	        sub     ecx, 20H
 0000029C  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000002A2  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B  ; Rotate left
	   93
 000002A7  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1
 000002AB  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000002B1  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 000002B6  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 10010011B  ; Rotate left
	   93
 000002BB  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0
 000002BF  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 000002C4  75 D3	     1	        jnz     ??0004
 000002C6  F7 C2 00000010    1	        test    edx, 10H
 000002CC  74 16	     1	        jz      ??0005
 000002CE  83 E9 10	     1	        sub     ecx, 10H
 000002D1  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000002D6  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B  ; Rotate left
	   93
 000002DB  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1
 000002DF  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000002E4		     1	??0005:     ; Get src pointer back to misaligned state
 000002E4  03 F0	     1	        add     esi, eax
 000002E6  E9 FFFFFE93	     1	        jmp     C200

				align 16
 000002F0  90			nop
				align 8
 000002F8  8D 40 01		lea eax,[eax+1]
 000002FB			D101:   MOVE_REVERSE_UNALIGNED_SSE2 1,   0
 000002FB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000300		     1	??0006:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000300  83 E9 20	     1	        sub     ecx, 20H
 00000303  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000309  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000030E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000312  66| 0F 73 F8	     1	        pslldq  xmm0, 16-1             ; shift left
	   0F
 00000317  66| 0F 73 D9	     1	        psrldq  xmm1, 1                ; shift right
	   01
 0000031C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000320  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000326  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000032A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-1             ; shift left
	   0F
 0000032F  66| 0F 73 DA	     1	        psrldq  xmm2, 1                ; shift right
	   01
 00000334  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000338  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000033D  75 C1	     1	        jnz     ??0006
 0000033F  F7 C2 00000010    1	        test    edx, 10H
 00000345  74 1B	     1	        jz      ??0007
 00000347  83 E9 10	     1	        sub     ecx, 10H
 0000034A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000034F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-1             ; shift left
	   0F
 00000354  66| 0F 73 D9	     1	        psrldq  xmm1, 1                ; shift right
	   01
 00000359  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000035D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000362		     1	??0007:     ; Get src pointer back to misaligned state
 00000362  03 F0	     1	        add     esi, eax
 00000364  E9 FFFFFE15	     1	        jmp     C200
 00000369  8B C0		mov eax,eax
 0000036B			D102:   MOVE_REVERSE_UNALIGNED_SSE2 2,   0
 0000036B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000370		     1	??0008:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000370  83 E9 20	     1	        sub     ecx, 20H
 00000373  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000379  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000037E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000382  66| 0F 73 F8	     1	        pslldq  xmm0, 16-2             ; shift left
	   0E
 00000387  66| 0F 73 D9	     1	        psrldq  xmm1, 2                ; shift right
	   02
 0000038C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000390  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000396  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000039A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-2             ; shift left
	   0E
 0000039F  66| 0F 73 DA	     1	        psrldq  xmm2, 2                ; shift right
	   02
 000003A4  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000003A8  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 000003AD  75 C1	     1	        jnz     ??0008
 000003AF  F7 C2 00000010    1	        test    edx, 10H
 000003B5  74 1B	     1	        jz      ??0009
 000003B7  83 E9 10	     1	        sub     ecx, 10H
 000003BA  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000003BF  66| 0F 73 F8	     1	        pslldq  xmm0, 16-2             ; shift left
	   0E
 000003C4  66| 0F 73 D9	     1	        psrldq  xmm1, 2                ; shift right
	   02
 000003C9  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000003CD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000003D2		     1	??0009:     ; Get src pointer back to misaligned state
 000003D2  03 F0	     1	        add     esi, eax
 000003D4  E9 FFFFFDA5	     1	        jmp     C200
 000003D9  8B C0		mov eax,eax
 000003DB			D103:   MOVE_REVERSE_UNALIGNED_SSE2 3,   0
 000003DB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 000003E0		     1	??000A:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000003E0  83 E9 20	     1	        sub     ecx, 20H
 000003E3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000003E9  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000003EE  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000003F2  66| 0F 73 F8	     1	        pslldq  xmm0, 16-3             ; shift left
	   0D
 000003F7  66| 0F 73 D9	     1	        psrldq  xmm1, 3                ; shift right
	   03
 000003FC  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000400  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000406  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000040A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-3             ; shift left
	   0D
 0000040F  66| 0F 73 DA	     1	        psrldq  xmm2, 3                ; shift right
	   03
 00000414  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000418  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000041D  75 C1	     1	        jnz     ??000A
 0000041F  F7 C2 00000010    1	        test    edx, 10H
 00000425  74 1B	     1	        jz      ??000B
 00000427  83 E9 10	     1	        sub     ecx, 10H
 0000042A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000042F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-3             ; shift left
	   0D
 00000434  66| 0F 73 D9	     1	        psrldq  xmm1, 3                ; shift right
	   03
 00000439  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000043D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000442		     1	??000B:     ; Get src pointer back to misaligned state
 00000442  03 F0	     1	        add     esi, eax
 00000444  E9 FFFFFD35	     1	        jmp     C200
 00000449  8B C0		mov eax,eax
 0000044B			D105:   MOVE_REVERSE_UNALIGNED_SSE2 5,   0
 0000044B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000450		     1	??000C:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000450  83 E9 20	     1	        sub     ecx, 20H
 00000453  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000459  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000045E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000462  66| 0F 73 F8	     1	        pslldq  xmm0, 16-5             ; shift left
	   0B
 00000467  66| 0F 73 D9	     1	        psrldq  xmm1, 5                ; shift right
	   05
 0000046C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000470  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000476  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000047A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-5             ; shift left
	   0B
 0000047F  66| 0F 73 DA	     1	        psrldq  xmm2, 5                ; shift right
	   05
 00000484  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000488  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000048D  75 C1	     1	        jnz     ??000C
 0000048F  F7 C2 00000010    1	        test    edx, 10H
 00000495  74 1B	     1	        jz      ??000D
 00000497  83 E9 10	     1	        sub     ecx, 10H
 0000049A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000049F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-5             ; shift left
	   0B
 000004A4  66| 0F 73 D9	     1	        psrldq  xmm1, 5                ; shift right
	   05
 000004A9  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000004AD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000004B2		     1	??000D:     ; Get src pointer back to misaligned state
 000004B2  03 F0	     1	        add     esi, eax
 000004B4  E9 FFFFFCC5	     1	        jmp     C200
 000004B9  8B C0		mov eax,eax
 000004BB			D106:   MOVE_REVERSE_UNALIGNED_SSE2 6,   0
 000004BB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 000004C0		     1	??000E:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000004C0  83 E9 20	     1	        sub     ecx, 20H
 000004C3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000004C9  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000004CE  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000004D2  66| 0F 73 F8	     1	        pslldq  xmm0, 16-6             ; shift left
	   0A
 000004D7  66| 0F 73 D9	     1	        psrldq  xmm1, 6                ; shift right
	   06
 000004DC  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000004E0  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000004E6  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000004EA  66| 0F 73 FB	     1	        pslldq  xmm3, 16-6             ; shift left
	   0A
 000004EF  66| 0F 73 DA	     1	        psrldq  xmm2, 6                ; shift right
	   06
 000004F4  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000004F8  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 000004FD  75 C1	     1	        jnz     ??000E
 000004FF  F7 C2 00000010    1	        test    edx, 10H
 00000505  74 1B	     1	        jz      ??000F
 00000507  83 E9 10	     1	        sub     ecx, 10H
 0000050A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000050F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-6             ; shift left
	   0A
 00000514  66| 0F 73 D9	     1	        psrldq  xmm1, 6                ; shift right
	   06
 00000519  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000051D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000522		     1	??000F:     ; Get src pointer back to misaligned state
 00000522  03 F0	     1	        add     esi, eax
 00000524  E9 FFFFFC55	     1	        jmp     C200
 00000529  8B C0		mov eax,eax
 0000052B			D107:   MOVE_REVERSE_UNALIGNED_SSE2 7,   0
 0000052B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000530		     1	??0010:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000530  83 E9 20	     1	        sub     ecx, 20H
 00000533  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000539  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000053E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000542  66| 0F 73 F8	     1	        pslldq  xmm0, 16-7             ; shift left
	   09
 00000547  66| 0F 73 D9	     1	        psrldq  xmm1, 7                ; shift right
	   07
 0000054C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000550  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000556  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000055A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-7             ; shift left
	   09
 0000055F  66| 0F 73 DA	     1	        psrldq  xmm2, 7                ; shift right
	   07
 00000564  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000568  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000056D  75 C1	     1	        jnz     ??0010
 0000056F  F7 C2 00000010    1	        test    edx, 10H
 00000575  74 1B	     1	        jz      ??0011
 00000577  83 E9 10	     1	        sub     ecx, 10H
 0000057A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000057F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-7             ; shift left
	   09
 00000584  66| 0F 73 D9	     1	        psrldq  xmm1, 7                ; shift right
	   07
 00000589  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000058D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000592		     1	??0011:     ; Get src pointer back to misaligned state
 00000592  03 F0	     1	        add     esi, eax
 00000594  E9 FFFFFBE5	     1	        jmp     C200
 00000599  8B C0		mov eax,eax
 0000059B			D109:   MOVE_REVERSE_UNALIGNED_SSE2 9,   0
 0000059B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 000005A0		     1	??0012:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000005A0  83 E9 20	     1	        sub     ecx, 20H
 000005A3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000005A9  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000005AE  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000005B2  66| 0F 73 F8	     1	        pslldq  xmm0, 16-9             ; shift left
	   07
 000005B7  66| 0F 73 D9	     1	        psrldq  xmm1, 9                ; shift right
	   09
 000005BC  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000005C0  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000005C6  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000005CA  66| 0F 73 FB	     1	        pslldq  xmm3, 16-9             ; shift left
	   07
 000005CF  66| 0F 73 DA	     1	        psrldq  xmm2, 9                ; shift right
	   09
 000005D4  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000005D8  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 000005DD  75 C1	     1	        jnz     ??0012
 000005DF  F7 C2 00000010    1	        test    edx, 10H
 000005E5  74 1B	     1	        jz      ??0013
 000005E7  83 E9 10	     1	        sub     ecx, 10H
 000005EA  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000005EF  66| 0F 73 F8	     1	        pslldq  xmm0, 16-9             ; shift left
	   07
 000005F4  66| 0F 73 D9	     1	        psrldq  xmm1, 9                ; shift right
	   09
 000005F9  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000005FD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000602		     1	??0013:     ; Get src pointer back to misaligned state
 00000602  03 F0	     1	        add     esi, eax
 00000604  E9 FFFFFB75	     1	        jmp     C200
 00000609  8B C0		mov eax,eax
 0000060B			D10A:   MOVE_REVERSE_UNALIGNED_SSE2 0AH, 0
 0000060B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000610		     1	??0014:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000610  83 E9 20	     1	        sub     ecx, 20H
 00000613  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000619  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000061E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000622  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0AH             ; shift left
	   06
 00000627  66| 0F 73 D9	     1	        psrldq  xmm1, 0AH                ; shift right
	   0A
 0000062C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000630  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000636  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000063A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0AH             ; shift left
	   06
 0000063F  66| 0F 73 DA	     1	        psrldq  xmm2, 0AH                ; shift right
	   0A
 00000644  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000648  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000064D  75 C1	     1	        jnz     ??0014
 0000064F  F7 C2 00000010    1	        test    edx, 10H
 00000655  74 1B	     1	        jz      ??0015
 00000657  83 E9 10	     1	        sub     ecx, 10H
 0000065A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000065F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0AH             ; shift left
	   06
 00000664  66| 0F 73 D9	     1	        psrldq  xmm1, 0AH                ; shift right
	   0A
 00000669  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000066D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000672		     1	??0015:     ; Get src pointer back to misaligned state
 00000672  03 F0	     1	        add     esi, eax
 00000674  E9 FFFFFB05	     1	        jmp     C200
 00000679  8B C0		mov eax,eax
 0000067B			D10B:   MOVE_REVERSE_UNALIGNED_SSE2 0BH, 0
 0000067B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000680		     1	??0016:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000680  83 E9 20	     1	        sub     ecx, 20H
 00000683  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000689  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000068E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000692  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0BH             ; shift left
	   05
 00000697  66| 0F 73 D9	     1	        psrldq  xmm1, 0BH                ; shift right
	   0B
 0000069C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000006A0  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000006A6  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000006AA  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0BH             ; shift left
	   05
 000006AF  66| 0F 73 DA	     1	        psrldq  xmm2, 0BH                ; shift right
	   0B
 000006B4  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000006B8  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 000006BD  75 C1	     1	        jnz     ??0016
 000006BF  F7 C2 00000010    1	        test    edx, 10H
 000006C5  74 1B	     1	        jz      ??0017
 000006C7  83 E9 10	     1	        sub     ecx, 10H
 000006CA  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000006CF  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0BH             ; shift left
	   05
 000006D4  66| 0F 73 D9	     1	        psrldq  xmm1, 0BH                ; shift right
	   0B
 000006D9  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000006DD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000006E2		     1	??0017:     ; Get src pointer back to misaligned state
 000006E2  03 F0	     1	        add     esi, eax
 000006E4  E9 FFFFFA95	     1	        jmp     C200
 000006E9  8B C0		mov eax,eax
 000006EB			D10D:   MOVE_REVERSE_UNALIGNED_SSE2 0DH, 0
 000006EB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 000006F0		     1	??0018:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000006F0  83 E9 20	     1	        sub     ecx, 20H
 000006F3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000006F9  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000006FE  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000702  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0DH             ; shift left
	   03
 00000707  66| 0F 73 D9	     1	        psrldq  xmm1, 0DH                ; shift right
	   0D
 0000070C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000710  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000716  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000071A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0DH             ; shift left
	   03
 0000071F  66| 0F 73 DA	     1	        psrldq  xmm2, 0DH                ; shift right
	   0D
 00000724  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000728  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000072D  75 C1	     1	        jnz     ??0018
 0000072F  F7 C2 00000010    1	        test    edx, 10H
 00000735  74 1B	     1	        jz      ??0019
 00000737  83 E9 10	     1	        sub     ecx, 10H
 0000073A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000073F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0DH             ; shift left
	   03
 00000744  66| 0F 73 D9	     1	        psrldq  xmm1, 0DH                ; shift right
	   0D
 00000749  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000074D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000752		     1	??0019:     ; Get src pointer back to misaligned state
 00000752  03 F0	     1	        add     esi, eax
 00000754  E9 FFFFFA25	     1	        jmp     C200
 00000759  8B C0		mov eax,eax
 0000075B			D10E:   MOVE_REVERSE_UNALIGNED_SSE2 0EH, 0
 0000075B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000760		     1	??001A:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000760  83 E9 20	     1	        sub     ecx, 20H
 00000763  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000769  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000076E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000772  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0EH             ; shift left
	   02
 00000777  66| 0F 73 D9	     1	        psrldq  xmm1, 0EH                ; shift right
	   0E
 0000077C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000780  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000786  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000078A  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0EH             ; shift left
	   02
 0000078F  66| 0F 73 DA	     1	        psrldq  xmm2, 0EH                ; shift right
	   0E
 00000794  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000798  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000079D  75 C1	     1	        jnz     ??001A
 0000079F  F7 C2 00000010    1	        test    edx, 10H
 000007A5  74 1B	     1	        jz      ??001B
 000007A7  83 E9 10	     1	        sub     ecx, 10H
 000007AA  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000007AF  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0EH             ; shift left
	   02
 000007B4  66| 0F 73 D9	     1	        psrldq  xmm1, 0EH                ; shift right
	   0E
 000007B9  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000007BD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000007C2		     1	??001B:     ; Get src pointer back to misaligned state
 000007C2  03 F0	     1	        add     esi, eax
 000007C4  E9 FFFFF9B5	     1	        jmp     C200
 000007C9  8B C0		mov eax,eax
 000007CB			D10F:   MOVE_REVERSE_UNALIGNED_SSE2 0FH, 0
 000007CB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 000007D0		     1	??001C:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000007D0  83 E9 20	     1	        sub     ecx, 20H
 000007D3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000007D9  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000007DE  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000007E2  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0FH             ; shift left
	   01
 000007E7  66| 0F 73 D9	     1	        psrldq  xmm1, 0FH                ; shift right
	   0F
 000007EC  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000007F0  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000007F6  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000007FA  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0FH             ; shift left
	   01
 000007FF  66| 0F 73 DA	     1	        psrldq  xmm2, 0FH                ; shift right
	   0F
 00000804  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000808  66| 0F 7F 1C 39   1	        movdqa  [edi+ecx], xmm3        ; Save aligned
 0000080D  75 C1	     1	        jnz     ??001C
 0000080F  F7 C2 00000010    1	        test    edx, 10H
 00000815  74 1B	     1	        jz      ??001D
 00000817  83 E9 10	     1	        sub     ecx, 10H
 0000081A  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000081F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0FH             ; shift left
	   01
 00000824  66| 0F 73 D9	     1	        psrldq  xmm1, 0FH                ; shift right
	   0F
 00000829  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000082D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000832		     1	??001D:     ; Get src pointer back to misaligned state
 00000832  03 F0	     1	        add     esi, eax
 00000834  E9 FFFFF945	     1	        jmp     C200

				; Make 15 instances of Sup.SSE3 macro for each value of the alignment u.
				; These are pointed to by the jump table MAlignmentDispatchSupSSE3 below

 00000839  8B C0		mov eax,eax
 0000083B			E101:   MOVE_REVERSE_UNALIGNED_SSSE3 1
 0000083B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000840		     1	??001E:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000840  83 E9 20	     1	        sub     ecx, 20H
 00000843  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000849  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 1          ; Combine parts into aligned block
	   01
 0000084F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000855  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 0000085A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 1          ; Combine parts into aligned block
	   01
 00000860  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000865  75 D9	     1	        jnz     ??001E
 00000867  F7 C2 00000010    1	        test    edx, 10H
 0000086D  74 13	     1	        jz      ??001F
 0000086F  83 E9 10	     1	        sub     ecx, 10H
 00000872  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000877  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 1          ; Combine parts into aligned block
	   01
 0000087D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000882		     1	??001F:     ; Get src pointer back to misaligned state
 00000882  03 F0	     1	        add     esi, eax
 00000884  E9 FFFFF8F5	     1	        jmp     C200
 00000889  8B C0		mov eax,eax
 0000088B			E102:   MOVE_REVERSE_UNALIGNED_SSSE3 2
 0000088B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000890		     1	??0020:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000890  83 E9 20	     1	        sub     ecx, 20H
 00000893  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000899  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 2          ; Combine parts into aligned block
	   02
 0000089F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000008A5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 000008AA  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 2          ; Combine parts into aligned block
	   02
 000008B0  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 000008B5  75 D9	     1	        jnz     ??0020
 000008B7  F7 C2 00000010    1	        test    edx, 10H
 000008BD  74 13	     1	        jz      ??0021
 000008BF  83 E9 10	     1	        sub     ecx, 10H
 000008C2  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 000008C7  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 2          ; Combine parts into aligned block
	   02
 000008CD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000008D2		     1	??0021:     ; Get src pointer back to misaligned state
 000008D2  03 F0	     1	        add     esi, eax
 000008D4  E9 FFFFF8A5	     1	        jmp     C200
 000008D9  8B C0		mov eax,eax
 000008DB			E103:   MOVE_REVERSE_UNALIGNED_SSSE3 3
 000008DB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 000008E0		     1	??0022:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000008E0  83 E9 20	     1	        sub     ecx, 20H
 000008E3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 000008E9  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 3          ; Combine parts into aligned block
	   03
 000008EF  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000008F5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 000008FA  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 3          ; Combine parts into aligned block
	   03
 00000900  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000905  75 D9	     1	        jnz     ??0022
 00000907  F7 C2 00000010    1	        test    edx, 10H
 0000090D  74 13	     1	        jz      ??0023
 0000090F  83 E9 10	     1	        sub     ecx, 10H
 00000912  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000917  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 3          ; Combine parts into aligned block
	   03
 0000091D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000922		     1	??0023:     ; Get src pointer back to misaligned state
 00000922  03 F0	     1	        add     esi, eax
 00000924  E9 FFFFF855	     1	        jmp     C200
 00000929  8B C0		mov eax,eax
 0000092B			E104:   MOVE_REVERSE_UNALIGNED_SSSE3 4
 0000092B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000930		     1	??0024:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000930  83 E9 20	     1	        sub     ecx, 20H
 00000933  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000939  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 4          ; Combine parts into aligned block
	   04 20
 0000093F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000945  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 0000094A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 4          ; Combine parts into aligned block
	   04
 00000950  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000955  75 D9	     1	        jnz     ??0024
 00000957  F7 C2 00000010    1	        test    edx, 10H
 0000095D  74 13	     1	        jz      ??0025
 0000095F  83 E9 10	     1	        sub     ecx, 10H
 00000962  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000967  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 4          ; Combine parts into aligned block
	   04 20
 0000096D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000972		     1	??0025:     ; Get src pointer back to misaligned state
 00000972  03 F0	     1	        add     esi, eax
 00000974  E9 FFFFF805	     1	        jmp     C200
 00000979  8B C0		mov eax,eax
 0000097B			E105:   MOVE_REVERSE_UNALIGNED_SSSE3 5
 0000097B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000980		     1	??0026:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000980  83 E9 20	     1	        sub     ecx, 20H
 00000983  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000989  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 5          ; Combine parts into aligned block
	   05
 0000098F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000995  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 0000099A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 5          ; Combine parts into aligned block
	   05
 000009A0  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 000009A5  75 D9	     1	        jnz     ??0026
 000009A7  F7 C2 00000010    1	        test    edx, 10H
 000009AD  74 13	     1	        jz      ??0027
 000009AF  83 E9 10	     1	        sub     ecx, 10H
 000009B2  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 000009B7  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 5          ; Combine parts into aligned block
	   05
 000009BD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000009C2		     1	??0027:     ; Get src pointer back to misaligned state
 000009C2  03 F0	     1	        add     esi, eax
 000009C4  E9 FFFFF7B5	     1	        jmp     C200
 000009C9  8B C0		mov eax,eax
 000009CB			E106:   MOVE_REVERSE_UNALIGNED_SSSE3 6
 000009CB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 000009D0		     1	??0028:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000009D0  83 E9 20	     1	        sub     ecx, 20H
 000009D3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 000009D9  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 6          ; Combine parts into aligned block
	   06
 000009DF  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000009E5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 000009EA  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 6          ; Combine parts into aligned block
	   06
 000009F0  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 000009F5  75 D9	     1	        jnz     ??0028
 000009F7  F7 C2 00000010    1	        test    edx, 10H
 000009FD  74 13	     1	        jz      ??0029
 000009FF  83 E9 10	     1	        sub     ecx, 10H
 00000A02  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000A07  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 6          ; Combine parts into aligned block
	   06
 00000A0D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000A12		     1	??0029:     ; Get src pointer back to misaligned state
 00000A12  03 F0	     1	        add     esi, eax
 00000A14  E9 FFFFF765	     1	        jmp     C200
 00000A19  8B C0		mov eax,eax
 00000A1B			E107:   MOVE_REVERSE_UNALIGNED_SSSE3 7
 00000A1B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000A20		     1	??002A:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000A20  83 E9 20	     1	        sub     ecx, 20H
 00000A23  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000A29  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 7          ; Combine parts into aligned block
	   07
 00000A2F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000A35  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000A3A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 7          ; Combine parts into aligned block
	   07
 00000A40  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000A45  75 D9	     1	        jnz     ??002A
 00000A47  F7 C2 00000010    1	        test    edx, 10H
 00000A4D  74 13	     1	        jz      ??002B
 00000A4F  83 E9 10	     1	        sub     ecx, 10H
 00000A52  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000A57  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 7          ; Combine parts into aligned block
	   07
 00000A5D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000A62		     1	??002B:     ; Get src pointer back to misaligned state
 00000A62  03 F0	     1	        add     esi, eax
 00000A64  E9 FFFFF715	     1	        jmp     C200
 00000A69  8B C0		mov eax,eax
 00000A6B			E108:   MOVE_REVERSE_UNALIGNED_SSSE3 8
 00000A6B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000A70		     1	??002C:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000A70  83 E9 20	     1	        sub     ecx, 20H
 00000A73  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000A79  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 8          ; Combine parts into aligned block
	   08
 00000A7F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000A85  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000A8A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 8          ; Combine parts into aligned block
	   08
 00000A90  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000A95  75 D9	     1	        jnz     ??002C
 00000A97  F7 C2 00000010    1	        test    edx, 10H
 00000A9D  74 13	     1	        jz      ??002D
 00000A9F  83 E9 10	     1	        sub     ecx, 10H
 00000AA2  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000AA7  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 8          ; Combine parts into aligned block
	   08
 00000AAD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000AB2		     1	??002D:     ; Get src pointer back to misaligned state
 00000AB2  03 F0	     1	        add     esi, eax
 00000AB4  E9 FFFFF6C5	     1	        jmp     C200
 00000AB9  8B C0		mov eax,eax
 00000ABB			E109:   MOVE_REVERSE_UNALIGNED_SSSE3 9
 00000ABB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000AC0		     1	??002E:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000AC0  83 E9 20	     1	        sub     ecx, 20H
 00000AC3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000AC9  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 9          ; Combine parts into aligned block
	   09
 00000ACF  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000AD5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000ADA  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 9          ; Combine parts into aligned block
	   09
 00000AE0  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000AE5  75 D9	     1	        jnz     ??002E
 00000AE7  F7 C2 00000010    1	        test    edx, 10H
 00000AED  74 13	     1	        jz      ??002F
 00000AEF  83 E9 10	     1	        sub     ecx, 10H
 00000AF2  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000AF7  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 9          ; Combine parts into aligned block
	   09
 00000AFD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000B02		     1	??002F:     ; Get src pointer back to misaligned state
 00000B02  03 F0	     1	        add     esi, eax
 00000B04  E9 FFFFF675	     1	        jmp     C200
 00000B09  8B C0		mov eax,eax
 00000B0B			E10A:   MOVE_REVERSE_UNALIGNED_SSSE3 0AH
 00000B0B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000B10		     1	??0030:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000B10  83 E9 20	     1	        sub     ecx, 20H
 00000B13  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000B19  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0AH          ; Combine parts into aligned block
	   0A
 00000B1F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000B25  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000B2A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 0AH          ; Combine parts into aligned block
	   0A
 00000B30  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000B35  75 D9	     1	        jnz     ??0030
 00000B37  F7 C2 00000010    1	        test    edx, 10H
 00000B3D  74 13	     1	        jz      ??0031
 00000B3F  83 E9 10	     1	        sub     ecx, 10H
 00000B42  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000B47  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0AH          ; Combine parts into aligned block
	   0A
 00000B4D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000B52		     1	??0031:     ; Get src pointer back to misaligned state
 00000B52  03 F0	     1	        add     esi, eax
 00000B54  E9 FFFFF625	     1	        jmp     C200
 00000B59  8B C0		mov eax,eax
 00000B5B			E10B:   MOVE_REVERSE_UNALIGNED_SSSE3 0BH
 00000B5B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000B60		     1	??0032:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000B60  83 E9 20	     1	        sub     ecx, 20H
 00000B63  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000B69  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0BH          ; Combine parts into aligned block
	   0B
 00000B6F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000B75  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000B7A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 0BH          ; Combine parts into aligned block
	   0B
 00000B80  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000B85  75 D9	     1	        jnz     ??0032
 00000B87  F7 C2 00000010    1	        test    edx, 10H
 00000B8D  74 13	     1	        jz      ??0033
 00000B8F  83 E9 10	     1	        sub     ecx, 10H
 00000B92  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000B97  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0BH          ; Combine parts into aligned block
	   0B
 00000B9D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000BA2		     1	??0033:     ; Get src pointer back to misaligned state
 00000BA2  03 F0	     1	        add     esi, eax
 00000BA4  E9 FFFFF5D5	     1	        jmp     C200
 00000BA9  8B C0		mov eax,eax
 00000BAB			E10C:   MOVE_REVERSE_UNALIGNED_SSSE3 0CH
 00000BAB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000BB0		     1	??0034:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000BB0  83 E9 20	     1	        sub     ecx, 20H
 00000BB3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000BB9  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0CH          ; Combine parts into aligned block
	   0C 20
 00000BBF  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000BC5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000BCA  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 0CH          ; Combine parts into aligned block
	   0C
 00000BD0  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000BD5  75 D9	     1	        jnz     ??0034
 00000BD7  F7 C2 00000010    1	        test    edx, 10H
 00000BDD  74 13	     1	        jz      ??0035
 00000BDF  83 E9 10	     1	        sub     ecx, 10H
 00000BE2  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000BE7  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0CH          ; Combine parts into aligned block
	   0C 20
 00000BED  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000BF2		     1	??0035:     ; Get src pointer back to misaligned state
 00000BF2  03 F0	     1	        add     esi, eax
 00000BF4  E9 FFFFF585	     1	        jmp     C200
 00000BF9  8B C0		mov eax,eax
 00000BFB			E10D:   MOVE_REVERSE_UNALIGNED_SSSE3 0DH
 00000BFB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000C00		     1	??0036:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000C00  83 E9 20	     1	        sub     ecx, 20H
 00000C03  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000C09  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0DH          ; Combine parts into aligned block
	   0D
 00000C0F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000C15  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000C1A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 0DH          ; Combine parts into aligned block
	   0D
 00000C20  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000C25  75 D9	     1	        jnz     ??0036
 00000C27  F7 C2 00000010    1	        test    edx, 10H
 00000C2D  74 13	     1	        jz      ??0037
 00000C2F  83 E9 10	     1	        sub     ecx, 10H
 00000C32  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000C37  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0DH          ; Combine parts into aligned block
	   0D
 00000C3D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000C42		     1	??0037:     ; Get src pointer back to misaligned state
 00000C42  03 F0	     1	        add     esi, eax
 00000C44  E9 FFFFF535	     1	        jmp     C200
 00000C49  8B C0		mov eax,eax
 00000C4B			E10E:   MOVE_REVERSE_UNALIGNED_SSSE3 0EH
 00000C4B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000C50		     1	??0038:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000C50  83 E9 20	     1	        sub     ecx, 20H
 00000C53  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000C59  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0EH          ; Combine parts into aligned block
	   0E
 00000C5F  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000C65  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000C6A  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 0EH          ; Combine parts into aligned block
	   0E
 00000C70  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000C75  75 D9	     1	        jnz     ??0038
 00000C77  F7 C2 00000010    1	        test    edx, 10H
 00000C7D  74 13	     1	        jz      ??0039
 00000C7F  83 E9 10	     1	        sub     ecx, 10H
 00000C82  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000C87  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0EH          ; Combine parts into aligned block
	   0E
 00000C8D  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000C92		     1	??0039:     ; Get src pointer back to misaligned state
 00000C92  03 F0	     1	        add     esi, eax
 00000C94  E9 FFFFF4E5	     1	        jmp     C200
 00000C99  8B C0		mov eax,eax
 00000C9B			E10F:   MOVE_REVERSE_UNALIGNED_SSSE3 0FH
 00000C9B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000CA0		     1	??003A:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000CA0  83 E9 20	     1	        sub     ecx, 20H
 00000CA3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks        
	   10
 00000CA9  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0FH          ; Combine parts into aligned block
	   0F
 00000CAF  66| 0F 7F 44 39   1	        movdqa  [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000CB5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00000CBA  66| 0F 3A 0F C8   1	        palignr xmm1, xmm0, 0FH          ; Combine parts into aligned block
	   0F 20
 00000CC0  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 00000CC5  75 D9	     1	        jnz     ??003A
 00000CC7  F7 C2 00000010    1	        test    edx, 10H
 00000CCD  74 13	     1	        jz      ??003B
 00000CCF  83 E9 10	     1	        sub     ecx, 10H
 00000CD2  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]        ; Read next two blocks        
 00000CD7  66| 0F 3A 0F C1   1	        palignr xmm0, xmm1, 0FH          ; Combine parts into aligned block
	   0F
 00000CDD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000CE2		     1	??003B:     ; Get src pointer back to misaligned state
 00000CE2  03 F0	     1	        add     esi, eax
 00000CE4  E9 FFFFF495	     1	        jmp     C200

				        
 00000CE9			F100:   ; Non-temporal move, src and dest have same alignment.
				        ; Loop. ecx has positive index from the beginning, counting down to zero
 00000CE9  83 E9 20		        sub     ecx, 20H
 00000CEC  0F 28 44 31 10	        movaps  xmm0, [esi+ecx+10H]
 00000CF1  0F 28 0C 31		        movaps  xmm1, [esi+ecx]
 00000CF5  0F 2B 44 39 10	        movntps [edi+ecx+10H], xmm0
 00000CFA  0F 2B 0C 39		        movntps [edi+ecx], xmm1
 00000CFE  75 E9		        jnz     F100
				        
				        ; Move the remaining edx bytes (0 - 31):
				        ; move 16-8-4-2-1 bytes, aligned
 00000D00  F7 C2 00000010	        test    edx, 10H
 00000D06  0F 84 FFFFF472	        jz      C200
				        ; move 16 bytes
 00000D0C  83 E9 10		        sub     ecx, 10H
 00000D0F  0F 28 04 31		        movaps  xmm0, [esi+ecx]
 00000D13  0F 2B 04 39		        movntps  [edi+ecx], xmm0
				        ; move the remaining 0 - 15 bytes
 00000D17  E9 FFFFF462		        jmp     C200

				; Non-temporal move, src and dest have different alignment.
				; Make 15 instances of SSE2 macro for each value of the alignment u.
				; These are pointed to by the jump table MAlignmentDispatchNT below

 00000D1C			F101:   MOVE_REVERSE_UNALIGNED_SSE2 1,   1
 00000D1C  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000D21		     1	??003C:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000D21  83 E9 20	     1	        sub     ecx, 20H
 00000D24  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000D2A  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00000D2F  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000D33  66| 0F 73 F8	     1	        pslldq  xmm0, 16-1             ; shift left
	   0F
 00000D38  66| 0F 73 D9	     1	        psrldq  xmm1, 1                ; shift right
	   01
 00000D3D  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000D41  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000D47  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000D4B  66| 0F 73 FB	     1	        pslldq  xmm3, 16-1             ; shift left
	   0F
 00000D50  66| 0F 73 DA	     1	        psrldq  xmm2, 1                ; shift right
	   01
 00000D55  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000D59  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00000D5E  75 C1	     1	        jnz     ??003C
 00000D60  F7 C2 00000010    1	        test    edx, 10H
 00000D66  74 1B	     1	        jz      ??003D
 00000D68  83 E9 10	     1	        sub     ecx, 10H
 00000D6B  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00000D70  66| 0F 73 F8	     1	        pslldq  xmm0, 16-1             ; shift left
	   0F
 00000D75  66| 0F 73 D9	     1	        psrldq  xmm1, 1                ; shift right
	   01
 00000D7A  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000D7E  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00000D83		     1	??003D:     ; Get src pointer back to misaligned state
 00000D83  03 F0	     1	        add     esi, eax
 00000D85  E9 FFFFF3F4	     1	        jmp     C200
 00000D8A			F102:   MOVE_REVERSE_UNALIGNED_SSE2 2,   1
 00000D8A  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000D8F		     1	??003E:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000D8F  83 E9 20	     1	        sub     ecx, 20H
 00000D92  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000D98  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00000D9D  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000DA1  66| 0F 73 F8	     1	        pslldq  xmm0, 16-2             ; shift left
	   0E
 00000DA6  66| 0F 73 D9	     1	        psrldq  xmm1, 2                ; shift right
	   02
 00000DAB  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000DAF  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000DB5  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000DB9  66| 0F 73 FB	     1	        pslldq  xmm3, 16-2             ; shift left
	   0E
 00000DBE  66| 0F 73 DA	     1	        psrldq  xmm2, 2                ; shift right
	   02
 00000DC3  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000DC7  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00000DCC  75 C1	     1	        jnz     ??003E
 00000DCE  F7 C2 00000010    1	        test    edx, 10H
 00000DD4  74 1B	     1	        jz      ??003F
 00000DD6  83 E9 10	     1	        sub     ecx, 10H
 00000DD9  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00000DDE  66| 0F 73 F8	     1	        pslldq  xmm0, 16-2             ; shift left
	   0E
 00000DE3  66| 0F 73 D9	     1	        psrldq  xmm1, 2                ; shift right
	   02
 00000DE8  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000DEC  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00000DF1		     1	??003F:     ; Get src pointer back to misaligned state
 00000DF1  03 F0	     1	        add     esi, eax
 00000DF3  E9 FFFFF386	     1	        jmp     C200
 00000DF8			F103:   MOVE_REVERSE_UNALIGNED_SSE2 3,   1
 00000DF8  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000DFD		     1	??0040:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000DFD  83 E9 20	     1	        sub     ecx, 20H
 00000E00  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000E06  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00000E0B  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000E0F  66| 0F 73 F8	     1	        pslldq  xmm0, 16-3             ; shift left
	   0D
 00000E14  66| 0F 73 D9	     1	        psrldq  xmm1, 3                ; shift right
	   03
 00000E19  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000E1D  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000E23  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000E27  66| 0F 73 FB	     1	        pslldq  xmm3, 16-3             ; shift left
	   0D
 00000E2C  66| 0F 73 DA	     1	        psrldq  xmm2, 3                ; shift right
	   03
 00000E31  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000E35  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00000E3A  75 C1	     1	        jnz     ??0040
 00000E3C  F7 C2 00000010    1	        test    edx, 10H
 00000E42  74 1B	     1	        jz      ??0041
 00000E44  83 E9 10	     1	        sub     ecx, 10H
 00000E47  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00000E4C  66| 0F 73 F8	     1	        pslldq  xmm0, 16-3             ; shift left
	   0D
 00000E51  66| 0F 73 D9	     1	        psrldq  xmm1, 3                ; shift right
	   03
 00000E56  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000E5A  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00000E5F		     1	??0041:     ; Get src pointer back to misaligned state
 00000E5F  03 F0	     1	        add     esi, eax
 00000E61  E9 FFFFF318	     1	        jmp     C200
 00000E66			F104:   MOVE_REVERSE_UNALIGNED_SSE2_4    1
 00000E66  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00000E6B		     1	??0042:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000E6B  83 E9 20	     1	        sub     ecx, 20H
 00000E6E  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000E74  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00000E79  66| 0F 6F D8	     1	        movdqa  xmm3, xmm0
 00000E7D  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2        
 00000E81  F3/ 0F 10 D1	     1	        movss   xmm2, xmm1
 00000E85  66| 0F 70 D2	     1	        pshufd  xmm2, xmm2, 00111001B  ; Rotate right
	   39
 00000E8A  F3/ 0F 10 CB	     1	        movss   xmm1, xmm3
 00000E8E  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 00111001B  ; Rotate right
	   39
 00000E93  66| 0F E7 4C 39   1	        movntdq [edi+ecx+10H], xmm1    ; Non-temporal save
	   10
 00000E99  66| 0F E7 14 39   1	        movntdq [edi+ecx], xmm2        ; Non-temporal save
 00000E9E  75 CB	     1	        jnz     ??0042
 00000EA0  F7 C2 00000010    1	        test    edx, 10H
 00000EA6  74 16	     1	        jz      ??0043
 00000EA8  83 E9 10	     1	        sub     ecx, 10H
 00000EAB  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00000EB0  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0
 00000EB4  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 00111001B  ; Rotate right
	   39
 00000EB9  66| 0F E7 0C 39   1	        movntdq [edi+ecx], xmm1        ; Non-temporal save
 00000EBE		     1	??0043:     ; Get src pointer back to misaligned state
 00000EBE  03 F0	     1	        add     esi, eax
 00000EC0  E9 FFFFF2B9	     1	        jmp     C200
 00000EC5			F105:   MOVE_REVERSE_UNALIGNED_SSE2 5,   1
 00000EC5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000ECA		     1	??0044:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000ECA  83 E9 20	     1	        sub     ecx, 20H
 00000ECD  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000ED3  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00000ED8  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000EDC  66| 0F 73 F8	     1	        pslldq  xmm0, 16-5             ; shift left
	   0B
 00000EE1  66| 0F 73 D9	     1	        psrldq  xmm1, 5                ; shift right
	   05
 00000EE6  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000EEA  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000EF0  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000EF4  66| 0F 73 FB	     1	        pslldq  xmm3, 16-5             ; shift left
	   0B
 00000EF9  66| 0F 73 DA	     1	        psrldq  xmm2, 5                ; shift right
	   05
 00000EFE  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000F02  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00000F07  75 C1	     1	        jnz     ??0044
 00000F09  F7 C2 00000010    1	        test    edx, 10H
 00000F0F  74 1B	     1	        jz      ??0045
 00000F11  83 E9 10	     1	        sub     ecx, 10H
 00000F14  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00000F19  66| 0F 73 F8	     1	        pslldq  xmm0, 16-5             ; shift left
	   0B
 00000F1E  66| 0F 73 D9	     1	        psrldq  xmm1, 5                ; shift right
	   05
 00000F23  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000F27  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00000F2C		     1	??0045:     ; Get src pointer back to misaligned state
 00000F2C  03 F0	     1	        add     esi, eax
 00000F2E  E9 FFFFF24B	     1	        jmp     C200
 00000F33			F106:   MOVE_REVERSE_UNALIGNED_SSE2 6,   1
 00000F33  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000F38		     1	??0046:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000F38  83 E9 20	     1	        sub     ecx, 20H
 00000F3B  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000F41  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00000F46  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000F4A  66| 0F 73 F8	     1	        pslldq  xmm0, 16-6             ; shift left
	   0A
 00000F4F  66| 0F 73 D9	     1	        psrldq  xmm1, 6                ; shift right
	   06
 00000F54  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000F58  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000F5E  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000F62  66| 0F 73 FB	     1	        pslldq  xmm3, 16-6             ; shift left
	   0A
 00000F67  66| 0F 73 DA	     1	        psrldq  xmm2, 6                ; shift right
	   06
 00000F6C  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000F70  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00000F75  75 C1	     1	        jnz     ??0046
 00000F77  F7 C2 00000010    1	        test    edx, 10H
 00000F7D  74 1B	     1	        jz      ??0047
 00000F7F  83 E9 10	     1	        sub     ecx, 10H
 00000F82  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00000F87  66| 0F 73 F8	     1	        pslldq  xmm0, 16-6             ; shift left
	   0A
 00000F8C  66| 0F 73 D9	     1	        psrldq  xmm1, 6                ; shift right
	   06
 00000F91  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000F95  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00000F9A		     1	??0047:     ; Get src pointer back to misaligned state
 00000F9A  03 F0	     1	        add     esi, eax
 00000F9C  E9 FFFFF1DD	     1	        jmp     C200
 00000FA1			F107:   MOVE_REVERSE_UNALIGNED_SSE2 7,   1
 00000FA1  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00000FA6		     1	??0048:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00000FA6  83 E9 20	     1	        sub     ecx, 20H
 00000FA9  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000FAF  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00000FB4  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000FB8  66| 0F 73 F8	     1	        pslldq  xmm0, 16-7             ; shift left
	   09
 00000FBD  66| 0F 73 D9	     1	        psrldq  xmm1, 7                ; shift right
	   07
 00000FC2  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000FC6  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00000FCC  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000FD0  66| 0F 73 FB	     1	        pslldq  xmm3, 16-7             ; shift left
	   09
 00000FD5  66| 0F 73 DA	     1	        psrldq  xmm2, 7                ; shift right
	   07
 00000FDA  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000FDE  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00000FE3  75 C1	     1	        jnz     ??0048
 00000FE5  F7 C2 00000010    1	        test    edx, 10H
 00000FEB  74 1B	     1	        jz      ??0049
 00000FED  83 E9 10	     1	        sub     ecx, 10H
 00000FF0  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00000FF5  66| 0F 73 F8	     1	        pslldq  xmm0, 16-7             ; shift left
	   09
 00000FFA  66| 0F 73 D9	     1	        psrldq  xmm1, 7                ; shift right
	   07
 00000FFF  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001003  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00001008		     1	??0049:     ; Get src pointer back to misaligned state
 00001008  03 F0	     1	        add     esi, eax
 0000100A  E9 FFFFF16F	     1	        jmp     C200
 0000100F			F108:   MOVE_REVERSE_UNALIGNED_SSE2_8    1
 0000100F  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 00001014  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B  ; Rotate
 00001018		     1	??004A:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00001018  83 E9 20	     1	        sub     ecx, 20H
 0000101B  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00001021  0F C6 C9 4E	     1	        shufps  xmm1, xmm1, 01001110B  ; Rotate
 00001025  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1
 00001029  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Non-temporal save
	   10
 0000102F  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 00001034  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B  ; Rotate
 00001038  F2/ 0F 10 C8	     1	        movsd   xmm1, xmm0
 0000103C  66| 0F E7 0C 39   1	        movntdq [edi+ecx], xmm1        ; Non-temporal save
 00001041  75 D5	     1	        jnz     ??004A
 00001043  F7 C2 00000010    1	        test    edx, 10H
 00001049  74 15	     1	        jz      ??004B
 0000104B  83 E9 10	     1	        sub     ecx, 10H
 0000104E  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00001053  0F C6 C9 4E	     1	        shufps  xmm1, xmm1, 01001110B  ; Rotate 
 00001057  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1
 0000105B  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Non-temporal save
 00001060		     1	??004B:     ; Get src pointer back to misaligned state
 00001060  03 F0	     1	        add     esi, eax
 00001062  E9 FFFFF117	     1	        jmp     C200
 00001067			F109:   MOVE_REVERSE_UNALIGNED_SSE2 9,   1
 00001067  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 0000106C		     1	??004C:     ; Loop. ecx has positive index from the beginning, counting down to zero
 0000106C  83 E9 20	     1	        sub     ecx, 20H
 0000106F  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00001075  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000107A  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 0000107E  66| 0F 73 F8	     1	        pslldq  xmm0, 16-9             ; shift left
	   07
 00001083  66| 0F 73 D9	     1	        psrldq  xmm1, 9                ; shift right
	   09
 00001088  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000108C  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00001092  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00001096  66| 0F 73 FB	     1	        pslldq  xmm3, 16-9             ; shift left
	   07
 0000109B  66| 0F 73 DA	     1	        psrldq  xmm2, 9                ; shift right
	   09
 000010A0  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000010A4  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 000010A9  75 C1	     1	        jnz     ??004C
 000010AB  F7 C2 00000010    1	        test    edx, 10H
 000010B1  74 1B	     1	        jz      ??004D
 000010B3  83 E9 10	     1	        sub     ecx, 10H
 000010B6  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000010BB  66| 0F 73 F8	     1	        pslldq  xmm0, 16-9             ; shift left
	   07
 000010C0  66| 0F 73 D9	     1	        psrldq  xmm1, 9                ; shift right
	   09
 000010C5  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000010C9  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 000010CE		     1	??004D:     ; Get src pointer back to misaligned state
 000010CE  03 F0	     1	        add     esi, eax
 000010D0  E9 FFFFF0A9	     1	        jmp     C200
 000010D5			F10A:   MOVE_REVERSE_UNALIGNED_SSE2 0AH, 1
 000010D5  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 000010DA		     1	??004E:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000010DA  83 E9 20	     1	        sub     ecx, 20H
 000010DD  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000010E3  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000010E8  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000010EC  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0AH             ; shift left
	   06
 000010F1  66| 0F 73 D9	     1	        psrldq  xmm1, 0AH                ; shift right
	   0A
 000010F6  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000010FA  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00001100  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00001104  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0AH             ; shift left
	   06
 00001109  66| 0F 73 DA	     1	        psrldq  xmm2, 0AH                ; shift right
	   0A
 0000110E  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00001112  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00001117  75 C1	     1	        jnz     ??004E
 00001119  F7 C2 00000010    1	        test    edx, 10H
 0000111F  74 1B	     1	        jz      ??004F
 00001121  83 E9 10	     1	        sub     ecx, 10H
 00001124  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00001129  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0AH             ; shift left
	   06
 0000112E  66| 0F 73 D9	     1	        psrldq  xmm1, 0AH                ; shift right
	   0A
 00001133  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001137  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 0000113C		     1	??004F:     ; Get src pointer back to misaligned state
 0000113C  03 F0	     1	        add     esi, eax
 0000113E  E9 FFFFF03B	     1	        jmp     C200
 00001143			F10B:   MOVE_REVERSE_UNALIGNED_SSE2 0BH, 1
 00001143  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00001148		     1	??0050:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00001148  83 E9 20	     1	        sub     ecx, 20H
 0000114B  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00001151  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00001156  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 0000115A  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0BH             ; shift left
	   05
 0000115F  66| 0F 73 D9	     1	        psrldq  xmm1, 0BH                ; shift right
	   0B
 00001164  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001168  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 0000116E  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00001172  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0BH             ; shift left
	   05
 00001177  66| 0F 73 DA	     1	        psrldq  xmm2, 0BH                ; shift right
	   0B
 0000117C  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00001180  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 00001185  75 C1	     1	        jnz     ??0050
 00001187  F7 C2 00000010    1	        test    edx, 10H
 0000118D  74 1B	     1	        jz      ??0051
 0000118F  83 E9 10	     1	        sub     ecx, 10H
 00001192  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00001197  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0BH             ; shift left
	   05
 0000119C  66| 0F 73 D9	     1	        psrldq  xmm1, 0BH                ; shift right
	   0B
 000011A1  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000011A5  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 000011AA		     1	??0051:     ; Get src pointer back to misaligned state
 000011AA  03 F0	     1	        add     esi, eax
 000011AC  E9 FFFFEFCD	     1	        jmp     C200
 000011B1			F10C:   MOVE_REVERSE_UNALIGNED_SSE2_12   1
 000011B1  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary
 000011B6  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 10010011B  ; Rotate right
	   93
 000011BB		     1	??0052:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000011BB  83 E9 20	     1	        sub     ecx, 20H
 000011BE  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000011C4  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B  ; Rotate left
	   93
 000011C9  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1
 000011CD  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Non-temporal save
	   10
 000011D3  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]
 000011D8  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 10010011B  ; Rotate left
	   93
 000011DD  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0
 000011E1  66| 0F E7 0C 39   1	        movntdq [edi+ecx], xmm1        ; Non-temporal save
 000011E6  75 D3	     1	        jnz     ??0052
 000011E8  F7 C2 00000010    1	        test    edx, 10H
 000011EE  74 16	     1	        jz      ??0053
 000011F0  83 E9 10	     1	        sub     ecx, 10H
 000011F3  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000011F8  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B  ; Rotate left
	   93
 000011FD  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1
 00001201  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Non-temporal save
 00001206		     1	??0053:     ; Get src pointer back to misaligned state
 00001206  03 F0	     1	        add     esi, eax
 00001208  E9 FFFFEF71	     1	        jmp     C200
 0000120D			F10D:   MOVE_REVERSE_UNALIGNED_SSE2 0DH, 1
 0000120D  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00001212		     1	??0054:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00001212  83 E9 20	     1	        sub     ecx, 20H
 00001215  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 0000121B  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 00001220  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001224  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0DH             ; shift left
	   03
 00001229  66| 0F 73 D9	     1	        psrldq  xmm1, 0DH                ; shift right
	   0D
 0000122E  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001232  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00001238  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000123C  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0DH             ; shift left
	   03
 00001241  66| 0F 73 DA	     1	        psrldq  xmm2, 0DH                ; shift right
	   0D
 00001246  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 0000124A  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 0000124F  75 C1	     1	        jnz     ??0054
 00001251  F7 C2 00000010    1	        test    edx, 10H
 00001257  74 1B	     1	        jz      ??0055
 00001259  83 E9 10	     1	        sub     ecx, 10H
 0000125C  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 00001261  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0DH             ; shift left
	   03
 00001266  66| 0F 73 D9	     1	        psrldq  xmm1, 0DH                ; shift right
	   0D
 0000126B  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000126F  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00001274		     1	??0055:     ; Get src pointer back to misaligned state
 00001274  03 F0	     1	        add     esi, eax
 00001276  E9 FFFFEF03	     1	        jmp     C200
 0000127B			F10E:   MOVE_REVERSE_UNALIGNED_SSE2 0EH, 1
 0000127B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 00001280		     1	??0056:     ; Loop. ecx has positive index from the beginning, counting down to zero
 00001280  83 E9 20	     1	        sub     ecx, 20H
 00001283  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00001289  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 0000128E  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001292  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0EH             ; shift left
	   02
 00001297  66| 0F 73 D9	     1	        psrldq  xmm1, 0EH                ; shift right
	   0E
 0000129C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000012A0  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 000012A6  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000012AA  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0EH             ; shift left
	   02
 000012AF  66| 0F 73 DA	     1	        psrldq  xmm2, 0EH                ; shift right
	   0E
 000012B4  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000012B8  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 000012BD  75 C1	     1	        jnz     ??0056
 000012BF  F7 C2 00000010    1	        test    edx, 10H
 000012C5  74 1B	     1	        jz      ??0057
 000012C7  83 E9 10	     1	        sub     ecx, 10H
 000012CA  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 000012CF  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0EH             ; shift left
	   02
 000012D4  66| 0F 73 D9	     1	        psrldq  xmm1, 0EH                ; shift right
	   0E
 000012D9  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000012DD  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 000012E2		     1	??0057:     ; Get src pointer back to misaligned state
 000012E2  03 F0	     1	        add     esi, eax
 000012E4  E9 FFFFEE95	     1	        jmp     C200
 000012E9			F10F:   MOVE_REVERSE_UNALIGNED_SSE2 0FH, 1
 000012E9  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest following 16B boundary        
 000012EE		     1	??0058:     ; Loop. ecx has positive index from the beginning, counting down to zero
 000012EE  83 E9 20	     1	        sub     ecx, 20H
 000012F1  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000012F7  66| 0F 6F 14 31   1	        movdqa  xmm2, [esi+ecx]
 000012FC  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001300  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0FH             ; shift left
	   01
 00001305  66| 0F 73 D9	     1	        psrldq  xmm1, 0FH                ; shift right
	   0F
 0000130A  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000130E  66| 0F E7 44 39   1	        movntdq [edi+ecx+10H], xmm0    ; Save aligned
	   10
 00001314  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00001318  66| 0F 73 FB	     1	        pslldq  xmm3, 16-0FH             ; shift left
	   01
 0000131D  66| 0F 73 DA	     1	        psrldq  xmm2, 0FH                ; shift right
	   0F
 00001322  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00001326  66| 0F E7 1C 39   1	        movntdq [edi+ecx], xmm3        ; Save aligned
 0000132B  75 C1	     1	        jnz     ??0058
 0000132D  F7 C2 00000010    1	        test    edx, 10H
 00001333  74 1B	     1	        jz      ??0059
 00001335  83 E9 10	     1	        sub     ecx, 10H
 00001338  66| 0F 6F 0C 31   1	        movdqa  xmm1, [esi+ecx]
 0000133D  66| 0F 73 F8	     1	        pslldq  xmm0, 16-0FH             ; shift left
	   01
 00001342  66| 0F 73 D9	     1	        psrldq  xmm1, 0FH                ; shift right
	   0F
 00001347  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000134B  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Save aligned
 00001350		     1	??0059:     ; Get src pointer back to misaligned state
 00001350  03 F0	     1	        add     esi, eax
 00001352  E9 FFFFEE27	     1	        jmp     C200

				IFDEF   POSITIONINDEPENDENT
				ENDIF

				; 80386 version used when SSE2 not supported:
 00001357			memmove386:
				; edi = dest
				; esi = src
				; ecx = count
 00001357  FD			        std                            ; Move backwards
 00001358  8D 7C 39 FF		        lea     edi, [edi+ecx-1]       ; Point to last byte of dest
 0000135C  8D 74 31 FF		        lea     esi, [esi+ecx-1]       ; Point to last byte of src
 00001360  83 F9 08		        cmp     ecx, 8
 00001363  72 2E		        jb      G500
 00001365  F7 C7 00000003	G100:   test    edi, 3                 ; Test if unaligned
 0000136B  74 04		        jz      G200
 0000136D  A4			        movsb
 0000136E  49			        dec     ecx
 0000136F  EB F4		        jmp     G100                   ; Repeat while edi unaligned
				        
 00001371			G200:   ; edi is aligned now. Move 4 bytes at a time
 00001371  83 EF 03		        sub     edi, 3                 ; Point to last dword of dest
 00001374  83 EE 03		        sub     esi, 3                 ; Point to last dword of src
 00001377  8B D1		        mov     edx, ecx
 00001379  C1 E9 02		        shr     ecx, 2
 0000137C  F3/ A5		        rep     movsd                  ; move 4 bytes at a time
 0000137E  8B CA		        mov     ecx, edx
 00001380  83 E1 03		        and     ecx, 3
 00001383  83 C7 03		        add     edi, 3                 ; Point to last byte of dest
 00001386  83 C6 03		        add     esi, 3                 ; Point to last byte of src        
 00001389  F3/ A4		        rep     movsb                  ; move remaining 0-3 bytes
 0000138B  FC			        cld
				        RETURNM
 0000138C  5F		     1	        pop     edi
 0000138D  5E		     1	        pop     esi
 0000138E  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 00001392  C3		     1	        ret
				        
 00001393			G500:   ; count < 8. Move one byte at a time
 00001393  F3/ A4		        rep     movsb                  ; move count bytes
 00001395  FC			        cld
				        RETURNM
 00001396  5F		     1	        pop     edi
 00001397  5E		     1	        pop     esi
 00001398  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 0000139C  C3		     1	        ret


				; CPU dispatching for memmove. This is executed only once
 0000139D			memmoveCPUDispatch:
				IFNDEF   POSITIONINDEPENDENT
 0000139D  60			        pushad
 0000139E  E8 00000000 E	        call    _InstructionSet
				        ; Point to generic version of memmove
 000013A3  C7 05 000000C0 R	        mov     [memmoveDispatch], offset memmove386
	   00001357 R
 000013AD  83 F8 04		        cmp     eax, 4                 ; check SSE2
 000013B0  72 21		        jb      M100
				        ; SSE2 supported
				        ; Point to SSE2 and later version of memmove
 000013B2  C7 05 000000C0 R	        mov     [memmoveDispatch], offset memmoveSSE2
	   00000020 R
 000013BC  83 F8 06		        cmp     eax, 6                 ; check Suppl-SSE3
 000013BF  72 12		        jb      M100
				        ; Suppl-SSE3 supported
				        ; Replace SSE2 alignment dispatch table with Suppl-SSE3 version        
 000013C1  BE 00000040 R	        mov     esi, offset MAlignmentDispatchSupSSE3
 000013C6  BF 00000000 R	        mov     edi, offset MAlignmentDispatchSSE2
 000013CB  B9 00000010		        mov     ecx, 16
 000013D0  FC			        cld
 000013D1  F3/ A5		        rep     movsd
 000013D3  61			M100:   popad
				        ; Continue in appropriate version of memmove
 000013D4  FF 25 000000C0 R	        jmp     [memmoveDispatch]

				ELSE    ; Position-independent version
				ENDIF


				; Data segment must be included in function namespace
 00000000			.data

				; Jump tables for alignments 0 - 15:
				; The CPU dispatcher replaces MAlignmentDispatchSSE2 with 
				; MAlignmentDispatchSupSSE3 if Suppl-SSE3 is supported
				; RP = reference point if position-independent code, otherwise RP = 0

 00000000			MAlignmentDispatch label dword
 00000000			MAlignmentDispatchSSE2 label dword
 00000000  00000150 R		DD C100-RP, D101-RP, D102-RP, D103-RP, D104-RP, D105-RP, D106-RP, D107-RP
	   000002FB R
	   0000036B R
	   000003DB R
	   000001D4 R
	   0000044B R
	   000004BB R
	   0000052B R
 00000020  00000237 R		DD D108-RP, D109-RP, D10A-RP, D10B-RP, D10C-RP, D10D-RP, D10E-RP, D10F-RP
	   0000059B R
	   0000060B R
	   0000067B R
	   0000028F R
	   000006EB R
	   0000075B R
	   000007CB R

 00000040			MAlignmentDispatchSupSSE3 label dword
 00000040  00000150 R		DD C100-RP, E101-RP, E102-RP, E103-RP, E104-RP, E105-RP, E106-RP, E107-RP
	   0000083B R
	   0000088B R
	   000008DB R
	   0000092B R
	   0000097B R
	   000009CB R
	   00000A1B R
 00000060  00000A6B R		DD E108-RP, E109-RP, E10A-RP, E10B-RP, E10C-RP, E10D-RP, E10E-RP, E10F-RP
	   00000ABB R
	   00000B0B R
	   00000B5B R
	   00000BAB R
	   00000BFB R
	   00000C4B R
	   00000C9B R

 00000080			MAlignmentDispatchNT label dword
 00000080  00000CE9 R		DD F100-RP, F101-RP, F102-RP, F103-RP, F104-RP, F105-RP, F106-RP, F107-RP
	   00000D1C R
	   00000D8A R
	   00000DF8 R
	   00000E66 R
	   00000EC5 R
	   00000F33 R
	   00000FA1 R
 000000A0  0000100F R		DD F108-RP, F109-RP, F10A-RP, F10B-RP, F10C-RP, F10D-RP, F10E-RP, F10F-RP
	   00001067 R
	   000010D5 R
	   00001143 R
	   000011B1 R
	   0000120D R
	   0000127B R
	   000012E9 R

				IFNDEF  POSITIONINDEPENDENT
				; Pointer to appropriate version.
				; This initially points to memmoveCPUDispatch. memmoveCPUDispatch will
				; change this to the appropriate version of memmove, so that
				; memmoveCPUDispatch is only executed once:
 000000C0 0000139D R		memmoveDispatch DD memmoveCPUDispatch
				ELSE
				ENDIF


 000013DA			.code

 000013DA			_A_memmove ENDP                        ; End of function namespace

				END
Microsoft (R) Macro Assembler Version 9.00.21022.08	    08/06/09 23:17:55
memmove32.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

MOVE_REVERSE_UNALIGNED_SSE2_12 .	Proc
MOVE_REVERSE_UNALIGNED_SSE2_4  .	Proc
MOVE_REVERSE_UNALIGNED_SSE2_8  .	Proc
MOVE_REVERSE_UNALIGNED_SSE2  . .	Proc
MOVE_REVERSE_UNALIGNED_SSSE3 . .	Proc
PICREFERENCE . . . . . . . . . .	Proc
RETURNM  . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 000000C4 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000013DA Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

_A_memmove . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000013DA Public
  memmoveSSE2  . . . . . . . . .	L Near	 00000020 _TEXT	
  A100 . . . . . . . . . . . . .	L Near	 00000062 _TEXT	
  A200 . . . . . . . . . . . . .	L Near	 00000083 _TEXT	
  A300 . . . . . . . . . . . . .	L Near	 00000098 _TEXT	
  A400 . . . . . . . . . . . . .	L Near	 000000AB _TEXT	
  A500 . . . . . . . . . . . . .	L Near	 000000BE _TEXT	
  A900 . . . . . . . . . . . . .	L Near	 000000CB _TEXT	
  B100 . . . . . . . . . . . . .	L Near	 000000D2 _TEXT	
  B200 . . . . . . . . . . . . .	L Near	 000000EF _TEXT	
  B210 . . . . . . . . . . . . .	L Near	 00000100 _TEXT	
  B220 . . . . . . . . . . . . .	L Near	 00000113 _TEXT	
  B300 . . . . . . . . . . . . .	L Near	 00000123 _TEXT	
  B400 . . . . . . . . . . . . .	L Near	 00000145 _TEXT	
  C100 . . . . . . . . . . . . .	L Near	 00000150 _TEXT	
  C200 . . . . . . . . . . . . .	L Near	 0000017E _TEXT	
  C210 . . . . . . . . . . . . .	L Near	 00000197 _TEXT	
  C220 . . . . . . . . . . . . .	L Near	 000001AA _TEXT	
  C230 . . . . . . . . . . . . .	L Near	 000001BD _TEXT	
  C500 . . . . . . . . . . . . .	L Near	 000001CD _TEXT	
  D104 . . . . . . . . . . . . .	L Near	 000001D4 _TEXT	
  ??0000 . . . . . . . . . . . .	L Near	 000001D9 _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 0000022C _TEXT	
  D108 . . . . . . . . . . . . .	L Near	 00000237 _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 00000240 _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 00000288 _TEXT	
  D10C . . . . . . . . . . . . .	L Near	 0000028F _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 00000299 _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 000002E4 _TEXT	
  D101 . . . . . . . . . . . . .	L Near	 000002FB _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 00000300 _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 00000362 _TEXT	
  D102 . . . . . . . . . . . . .	L Near	 0000036B _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 00000370 _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 000003D2 _TEXT	
  D103 . . . . . . . . . . . . .	L Near	 000003DB _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 000003E0 _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 00000442 _TEXT	
  D105 . . . . . . . . . . . . .	L Near	 0000044B _TEXT	
  ??000C . . . . . . . . . . . .	L Near	 00000450 _TEXT	
  ??000D . . . . . . . . . . . .	L Near	 000004B2 _TEXT	
  D106 . . . . . . . . . . . . .	L Near	 000004BB _TEXT	
  ??000E . . . . . . . . . . . .	L Near	 000004C0 _TEXT	
  ??000F . . . . . . . . . . . .	L Near	 00000522 _TEXT	
  D107 . . . . . . . . . . . . .	L Near	 0000052B _TEXT	
  ??0010 . . . . . . . . . . . .	L Near	 00000530 _TEXT	
  ??0011 . . . . . . . . . . . .	L Near	 00000592 _TEXT	
  D109 . . . . . . . . . . . . .	L Near	 0000059B _TEXT	
  ??0012 . . . . . . . . . . . .	L Near	 000005A0 _TEXT	
  ??0013 . . . . . . . . . . . .	L Near	 00000602 _TEXT	
  D10A . . . . . . . . . . . . .	L Near	 0000060B _TEXT	
  ??0014 . . . . . . . . . . . .	L Near	 00000610 _TEXT	
  ??0015 . . . . . . . . . . . .	L Near	 00000672 _TEXT	
  D10B . . . . . . . . . . . . .	L Near	 0000067B _TEXT	
  ??0016 . . . . . . . . . . . .	L Near	 00000680 _TEXT	
  ??0017 . . . . . . . . . . . .	L Near	 000006E2 _TEXT	
  D10D . . . . . . . . . . . . .	L Near	 000006EB _TEXT	
  ??0018 . . . . . . . . . . . .	L Near	 000006F0 _TEXT	
  ??0019 . . . . . . . . . . . .	L Near	 00000752 _TEXT	
  D10E . . . . . . . . . . . . .	L Near	 0000075B _TEXT	
  ??001A . . . . . . . . . . . .	L Near	 00000760 _TEXT	
  ??001B . . . . . . . . . . . .	L Near	 000007C2 _TEXT	
  D10F . . . . . . . . . . . . .	L Near	 000007CB _TEXT	
  ??001C . . . . . . . . . . . .	L Near	 000007D0 _TEXT	
  ??001D . . . . . . . . . . . .	L Near	 00000832 _TEXT	
  E101 . . . . . . . . . . . . .	L Near	 0000083B _TEXT	
  ??001E . . . . . . . . . . . .	L Near	 00000840 _TEXT	
  ??001F . . . . . . . . . . . .	L Near	 00000882 _TEXT	
  E102 . . . . . . . . . . . . .	L Near	 0000088B _TEXT	
  ??0020 . . . . . . . . . . . .	L Near	 00000890 _TEXT	
  ??0021 . . . . . . . . . . . .	L Near	 000008D2 _TEXT	
  E103 . . . . . . . . . . . . .	L Near	 000008DB _TEXT	
  ??0022 . . . . . . . . . . . .	L Near	 000008E0 _TEXT	
  ??0023 . . . . . . . . . . . .	L Near	 00000922 _TEXT	
  E104 . . . . . . . . . . . . .	L Near	 0000092B _TEXT	
  ??0024 . . . . . . . . . . . .	L Near	 00000930 _TEXT	
  ??0025 . . . . . . . . . . . .	L Near	 00000972 _TEXT	
  E105 . . . . . . . . . . . . .	L Near	 0000097B _TEXT	
  ??0026 . . . . . . . . . . . .	L Near	 00000980 _TEXT	
  ??0027 . . . . . . . . . . . .	L Near	 000009C2 _TEXT	
  E106 . . . . . . . . . . . . .	L Near	 000009CB _TEXT	
  ??0028 . . . . . . . . . . . .	L Near	 000009D0 _TEXT	
  ??0029 . . . . . . . . . . . .	L Near	 00000A12 _TEXT	
  E107 . . . . . . . . . . . . .	L Near	 00000A1B _TEXT	
  ??002A . . . . . . . . . . . .	L Near	 00000A20 _TEXT	
  ??002B . . . . . . . . . . . .	L Near	 00000A62 _TEXT	
  E108 . . . . . . . . . . . . .	L Near	 00000A6B _TEXT	
  ??002C . . . . . . . . . . . .	L Near	 00000A70 _TEXT	
  ??002D . . . . . . . . . . . .	L Near	 00000AB2 _TEXT	
  E109 . . . . . . . . . . . . .	L Near	 00000ABB _TEXT	
  ??002E . . . . . . . . . . . .	L Near	 00000AC0 _TEXT	
  ??002F . . . . . . . . . . . .	L Near	 00000B02 _TEXT	
  E10A . . . . . . . . . . . . .	L Near	 00000B0B _TEXT	
  ??0030 . . . . . . . . . . . .	L Near	 00000B10 _TEXT	
  ??0031 . . . . . . . . . . . .	L Near	 00000B52 _TEXT	
  E10B . . . . . . . . . . . . .	L Near	 00000B5B _TEXT	
  ??0032 . . . . . . . . . . . .	L Near	 00000B60 _TEXT	
  ??0033 . . . . . . . . . . . .	L Near	 00000BA2 _TEXT	
  E10C . . . . . . . . . . . . .	L Near	 00000BAB _TEXT	
  ??0034 . . . . . . . . . . . .	L Near	 00000BB0 _TEXT	
  ??0035 . . . . . . . . . . . .	L Near	 00000BF2 _TEXT	
  E10D . . . . . . . . . . . . .	L Near	 00000BFB _TEXT	
  ??0036 . . . . . . . . . . . .	L Near	 00000C00 _TEXT	
  ??0037 . . . . . . . . . . . .	L Near	 00000C42 _TEXT	
  E10E . . . . . . . . . . . . .	L Near	 00000C4B _TEXT	
  ??0038 . . . . . . . . . . . .	L Near	 00000C50 _TEXT	
  ??0039 . . . . . . . . . . . .	L Near	 00000C92 _TEXT	
  E10F . . . . . . . . . . . . .	L Near	 00000C9B _TEXT	
  ??003A . . . . . . . . . . . .	L Near	 00000CA0 _TEXT	
  ??003B . . . . . . . . . . . .	L Near	 00000CE2 _TEXT	
  F100 . . . . . . . . . . . . .	L Near	 00000CE9 _TEXT	
  F101 . . . . . . . . . . . . .	L Near	 00000D1C _TEXT	
  ??003C . . . . . . . . . . . .	L Near	 00000D21 _TEXT	
  ??003D . . . . . . . . . . . .	L Near	 00000D83 _TEXT	
  F102 . . . . . . . . . . . . .	L Near	 00000D8A _TEXT	
  ??003E . . . . . . . . . . . .	L Near	 00000D8F _TEXT	
  ??003F . . . . . . . . . . . .	L Near	 00000DF1 _TEXT	
  F103 . . . . . . . . . . . . .	L Near	 00000DF8 _TEXT	
  ??0040 . . . . . . . . . . . .	L Near	 00000DFD _TEXT	
  ??0041 . . . . . . . . . . . .	L Near	 00000E5F _TEXT	
  F104 . . . . . . . . . . . . .	L Near	 00000E66 _TEXT	
  ??0042 . . . . . . . . . . . .	L Near	 00000E6B _TEXT	
  ??0043 . . . . . . . . . . . .	L Near	 00000EBE _TEXT	
  F105 . . . . . . . . . . . . .	L Near	 00000EC5 _TEXT	
  ??0044 . . . . . . . . . . . .	L Near	 00000ECA _TEXT	
  ??0045 . . . . . . . . . . . .	L Near	 00000F2C _TEXT	
  F106 . . . . . . . . . . . . .	L Near	 00000F33 _TEXT	
  ??0046 . . . . . . . . . . . .	L Near	 00000F38 _TEXT	
  ??0047 . . . . . . . . . . . .	L Near	 00000F9A _TEXT	
  F107 . . . . . . . . . . . . .	L Near	 00000FA1 _TEXT	
  ??0048 . . . . . . . . . . . .	L Near	 00000FA6 _TEXT	
  ??0049 . . . . . . . . . . . .	L Near	 00001008 _TEXT	
  F108 . . . . . . . . . . . . .	L Near	 0000100F _TEXT	
  ??004A . . . . . . . . . . . .	L Near	 00001018 _TEXT	
  ??004B . . . . . . . . . . . .	L Near	 00001060 _TEXT	
  F109 . . . . . . . . . . . . .	L Near	 00001067 _TEXT	
  ??004C . . . . . . . . . . . .	L Near	 0000106C _TEXT	
  ??004D . . . . . . . . . . . .	L Near	 000010CE _TEXT	
  F10A . . . . . . . . . . . . .	L Near	 000010D5 _TEXT	
  ??004E . . . . . . . . . . . .	L Near	 000010DA _TEXT	
  ??004F . . . . . . . . . . . .	L Near	 0000113C _TEXT	
  F10B . . . . . . . . . . . . .	L Near	 00001143 _TEXT	
  ??0050 . . . . . . . . . . . .	L Near	 00001148 _TEXT	
  ??0051 . . . . . . . . . . . .	L Near	 000011AA _TEXT	
  F10C . . . . . . . . . . . . .	L Near	 000011B1 _TEXT	
  ??0052 . . . . . . . . . . . .	L Near	 000011BB _TEXT	
  ??0053 . . . . . . . . . . . .	L Near	 00001206 _TEXT	
  F10D . . . . . . . . . . . . .	L Near	 0000120D _TEXT	
  ??0054 . . . . . . . . . . . .	L Near	 00001212 _TEXT	
  ??0055 . . . . . . . . . . . .	L Near	 00001274 _TEXT	
  F10E . . . . . . . . . . . . .	L Near	 0000127B _TEXT	
  ??0056 . . . . . . . . . . . .	L Near	 00001280 _TEXT	
  ??0057 . . . . . . . . . . . .	L Near	 000012E2 _TEXT	
  F10F . . . . . . . . . . . . .	L Near	 000012E9 _TEXT	
  ??0058 . . . . . . . . . . . .	L Near	 000012EE _TEXT	
  ??0059 . . . . . . . . . . . .	L Near	 00001350 _TEXT	
  memmove386 . . . . . . . . . .	L Near	 00001357 _TEXT	
  G100 . . . . . . . . . . . . .	L Near	 00001365 _TEXT	
  G200 . . . . . . . . . . . . .	L Near	 00001371 _TEXT	
  G500 . . . . . . . . . . . . .	L Near	 00001393 _TEXT	
  memmoveCPUDispatch . . . . . .	L Near	 0000139D _TEXT	
  M100 . . . . . . . . . . . . .	L Near	 000013D3 _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

$memcpyEntry2  . . . . . . . . .	L Near	 00000000 FLAT	External
?OVR_memmove . . . . . . . . . .	L Near	 00000000 _TEXT	Public
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
MAlignmentDispatchNT . . . . . .	DWord	 00000080 _DATA	
MAlignmentDispatchSSE2 . . . . .	DWord	 00000000 _DATA	
MAlignmentDispatchSupSSE3  . . .	DWord	 00000040 _DATA	
MAlignmentDispatch . . . . . . .	DWord	 00000000 _DATA	
RP . . . . . . . . . . . . . . .	Number	 00000000h   
_CacheBypassLimit  . . . . . . .	DWord	 00000000 FLAT	External
_InstructionSet  . . . . . . . .	L Near	 00000000 FLAT	External
memmoveDispatch  . . . . . . . .	DWord	 000000C0 _DATA	

	   0 Warnings
	   0 Errors
