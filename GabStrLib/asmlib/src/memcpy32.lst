Microsoft (R) Macro Assembler Version 9.00.21022.08	    08/06/09 23:17:55
memcpy32.asm						     Page 1 - 1


				;*************************  memcpy32.asm  ************************************
				; Author:           Agner Fog
				; Date created:     2008-07-18
				; Last modified:    2008-07-18
				; Description:
				; Faster version of the standard memcpy function:
				; void * A_memcpy(void *dest, const void *src, size_t count);
				; Copies 'count' bytes from 'src' to 'dest'
				;
				; Overriding standard function memcpy:
				; The alias ?OVR_memcpy is changed to _memcpy in the object file if
				; it is desired to override the standard library function memcpy.
				;
				; Position-independent code is generated if POSITIONINDEPENDENT is defined.
				;
				; Optimization:
				; Uses XMM registers to copy 16 bytes at a time, aligned.
				; If source and destination are misaligned relative to each other
				; then the code will combine parts of every two consecutive 16-bytes 
				; blocks from the source into one 16-bytes register which is written 
				; to the destination, aligned.
				; This method is 2 - 6 times faster than the implementations in the
				; standard C libraries (MS, Gnu) when src or dest are misaligned.
				; When src and dest are aligned by 16 (relative to each other) then this
				; function is only slightly faster than the best standard libraries.
				; CPU dispatching included for 386, SSE2 and Suppl-SSE3 instruction sets.
				;
				; Future extensions:
				; Implementations for the AMD SSE5 and Intel AVX instruction sets are 
				; illustrated in www.agner.org/optimize/asmexamples.zip
				;
				; Copyright (c) 2008 GNU General Public License www.gnu.org/licenses/gpl.html
				;******************************************************************************
				.686
				.xmm
				.model flat

				public _A_memcpy                       ; Function A_memcpy
				public ?OVR_memcpy                     ; ?OVR removed if standard function memcpy overridden
				public $memcpyEntry2                   ; Entry from memmove
				public _CacheBypassLimit               ; Bypass cache if count > _CacheBypassLimit


				; Imported from instrset32.asm
				extern _InstructionSet: near           ; Instruction set for CPU dispatcher

				; Define return from this function
				RETURNM MACRO
				IFDEF   POSITIONINDEPENDENT
				        pop     ebx
				ENDIF
				        pop     edi
				        pop     esi
				        mov     eax, [esp+4]           ; Return value = dest
				        ret
				ENDM

				; Macro for arbitrary instruction with position-independent reference
				PICREFERENCE MACRO TARGET, REFPOINT, BYTE1, BYTE2, BYTE3
				; Make position-independent instrution of the form
				; add eax, [ebx+TARGET-REFPOINT]
				; where ebx contains the address of REFPOINT
				; BYTE1, BYTE2, BYTE3 are the first 2 or 3 bytes of the instruction
				; add eax, [ebx+????]
				; (as obtained from an assembly listing) including opcode byte, 
				; mod/reg/rm byte and possibly sib byte, but not including the 4-bytes 
				; offset which is generated by this macro.
				; Any instruction and any registers can be coded into BYTE1, BYTE2, BYTE3.

				local p0, p1, p2
				; Insert byte codes except last one
				p0:
				   db  BYTE1
				IFNB  <BYTE3>      ; if BYTE3 not blank
				   db  BYTE2
				ENDIF   
				p1:   
				; Make bogus CALL instruction for making self-relative reference.
				; This is the only way the assembler can make a self-relative reference
				   call near ptr TARGET + (p2-REFPOINT) 
				p2:
				; back-patch CALL instruction to change it to the desired instruction
				; by replacing CALL opcode by the last byte of desired instruction
				   org p1
				IFNB  <BYTE3>      ; if BYTE3 not blank
				   db  BYTE3
				ELSE
				   db  BYTE2
				ENDIF
				   org p2          ; Back to end of instruction
				ENDM 


 00000000			.code

				; extern "C" void * A_memcpy(void * dest, const void * src, size_t count);
				; Function entry:
 00000000			_A_memcpy PROC    NEAR
 00000000			?OVR_memcpy LABEL NEAR
 00000000  56			        push    esi
 00000001  57			        push    edi
 00000002  8B 7C 24 0C		        mov     edi, [esp+12]          ; dest
 00000006  8B 74 24 10		        mov     esi, [esp+16]          ; src
 0000000A  8B 4C 24 14		        mov     ecx, [esp+20]          ; count
 0000000E			$memcpyEntry2 label near               ; Entry from memmove

				IFNDEF  POSITIONINDEPENDENT
 0000000E  FF 25 000000C0 R	        jmp     [memcpyDispatch]       ; Go to appropriate version, depending on instruction set
 = 00000000			RP      equ     0                      ; RP = 0 if not position-independent

				ELSE    ; Position-independent code
				ENDIF
				        
				        
 00000014			memcpySSE2: ; SSE2 and later versions begin here        
 00000014  83 F9 40		        cmp     ecx, 40H
 00000017  0F 83 0000009F	        jae     B100                   ; Use simpler code if count < 64
				        
				        ; count < 64. Move 32-16-8-4-2-1 bytes
 0000001D  03 F1		        add     esi, ecx               ; end of src
 0000001F  03 F9		        add     edi, ecx               ; end of dest
 00000021  F7 D9		        neg     ecx                    ; negative index from the end
 00000023  83 F9 E0		        cmp     ecx, -20H
 00000026  7F 31		        jg      A100        
				        ; move 32 bytes
				        ; movq is faster than movdqu on current processors (2008),
				        ; movdqu may be faster on future processors
 00000028  F3/ 0F 7E 04 31	        movq    xmm0, qword ptr [esi+ecx]
 0000002D  F3/ 0F 7E 4C 31	        movq    xmm1, qword ptr [esi+ecx+8]
	   08
 00000033  F3/ 0F 7E 54 31	        movq    xmm2, qword ptr [esi+ecx+10H]
	   10
 00000039  F3/ 0F 7E 5C 31	        movq    xmm3, qword ptr [esi+ecx+18H]
	   18
 0000003F  66| 0F D6 04 39	        movq    qword ptr [edi+ecx], xmm0
 00000044  66| 0F D6 4C 39	        movq    qword ptr [edi+ecx+8], xmm1
	   08
 0000004A  66| 0F D6 54 39	        movq    qword ptr [edi+ecx+10H], xmm2
	   10
 00000050  66| 0F D6 5C 39	        movq    qword ptr [edi+ecx+18H], xmm3
	   18
 00000056  83 C1 20		        add     ecx, 20H
 00000059  83 F9 F0		A100:   cmp     ecx, -10H        
 0000005C  7F 19		        jg      A200
				        ; move 16 bytes
 0000005E  F3/ 0F 7E 04 31	        movq    xmm0, qword ptr [esi+ecx]
 00000063  F3/ 0F 7E 4C 31	        movq    xmm1, qword ptr [esi+ecx+8]
	   08
 00000069  66| 0F D6 04 39	        movq    qword ptr [edi+ecx], xmm0
 0000006E  66| 0F D6 4C 39	        movq    qword ptr [edi+ecx+8], xmm1
	   08
 00000074  83 C1 10		        add     ecx, 10H
 00000077  83 F9 F8		A200:   cmp     ecx, -8        
 0000007A  7F 0D		        jg      A300
				        ; move 8 bytes
 0000007C  F3/ 0F 7E 04 31	        movq    xmm0, qword ptr [esi+ecx]
 00000081  66| 0F D6 04 39	        movq    qword ptr [edi+ecx], xmm0
 00000086  83 C1 08		        add     ecx, 8
 00000089  83 F9 FC		A300:   cmp     ecx, -4        
 0000008C  7F 0B		        jg      A400
				        ; move 4 bytes
 0000008E  8B 04 31		        mov     eax, [esi+ecx]
 00000091  89 04 39		        mov     [edi+ecx], eax
 00000094  83 C1 04		        add     ecx, 4
 00000097  74 1C		        jz      A900                     ; early out if count divisible by 4
 00000099  83 F9 FE		A400:   cmp     ecx, -2        
 0000009C  7F 0B		        jg      A500
				        ; move 2 bytes
 0000009E  0F B7 04 31		        movzx   eax, word ptr [esi+ecx]
 000000A2  66| 89 04 39		        mov     [edi+ecx], ax
 000000A6  83 C1 02		        add     ecx, 2
 000000A9  83 F9 FF		A500:   cmp     ecx, -1
 000000AC  7F 07		        jg      A900        
				        ; move 1 byte
 000000AE  0F B6 04 31		        movzx   eax, byte ptr [esi+ecx]
 000000B2  88 04 39		        mov     [edi+ecx], al
 000000B5			A900:   ; finished
				        RETURNM        
 000000B5  5F		     1	        pop     edi
 000000B6  5E		     1	        pop     esi
 000000B7  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 000000BB  C3		     1	        ret
				        
 000000BC			B100:   ; count >= 64
				        ; Note: this part will not always work if count < 64
				        ; Calculate size of first block up to first regular boundary of dest
 000000BC  8B D7		        mov     edx, edi
 000000BE  F7 DA		        neg     edx
 000000C0  83 E2 0F		        and     edx, 0FH
 000000C3  74 44		        jz      B300                    ; Skip if dest aligned by 16
				        
				        ; edx = size of first partial block, 1 - 15 bytes
 000000C5  03 F2		        add     esi, edx
 000000C7  03 FA		        add     edi, edx
 000000C9  2B CA		        sub     ecx, edx
 000000CB  F7 DA		        neg     edx
 000000CD  83 FA F8		        cmp     edx, -8
 000000D0  7F 0D		        jg      B200
				        ; move 8 bytes
 000000D2  F3/ 0F 7E 04 32	        movq    xmm0, qword ptr [esi+edx]
 000000D7  66| 0F D6 04 3A	        movq    qword ptr [edi+edx], xmm0
 000000DC  83 C2 08		        add     edx, 8
 000000DF  83 FA FC		B200:   cmp     edx, -4        
 000000E2  7F 09		        jg      B210
				        ; move 4 bytes
 000000E4  8B 04 32		        mov     eax, [esi+edx]
 000000E7  89 04 3A		        mov     [edi+edx], eax
 000000EA  83 C2 04		        add     edx, 4
 000000ED  83 FA FE		B210:   cmp     edx, -2        
 000000F0  7F 0B		        jg      B220
				        ; move 2 bytes
 000000F2  0F B7 04 32		        movzx   eax, word ptr [esi+edx]
 000000F6  66| 89 04 3A		        mov     [edi+edx], ax
 000000FA  83 C2 02		        add     edx, 2
 000000FD  83 FA FF		B220:   cmp     edx, -1
 00000100  7F 07		        jg      B300
				        ; move 1 byte
 00000102  0F B6 04 32		        movzx   eax, byte ptr [esi+edx]
 00000106  88 04 3A		        mov     [edi+edx], al
				        
 00000109			B300:   ; Now dest is aligned by 16. Any partial block has been moved        
				        ; Find alignment of src modulo 16 at this point:
 00000109  8B C6		        mov     eax, esi
 0000010B  83 E0 0F		        and     eax, 0FH
				        
				        ; Set up for loop moving 32 bytes per iteration:
 0000010E  8B D1		        mov     edx, ecx               ; Save count
 00000110  83 E1 E0		        and     ecx, -20H              ; Round down to nearest multiple of 32
 00000113  03 F1		        add     esi, ecx               ; Point to the end
 00000115  03 F9		        add     edi, ecx               ; Point to the end
 00000117  2B D1		        sub     edx, ecx               ; Remaining data after loop
 00000119  2B F0		        sub     esi, eax               ; Nearest preceding aligned block of src

				IFNDEF  POSITIONINDEPENDENT
				        ; Check if count very big
 0000011B  3B 0D 000000C4 R	        cmp     ecx, [_CacheBypassLimit]
 00000121  77 09		        ja      B400                   ; Use non-temporal store if count > _CacheBypassLimit
 00000123  F7 D9		        neg     ecx                    ; Negative index from the end
				        
				        ; Dispatch to different codes depending on src alignment
 00000125  FF 24 85		        jmp     AlignmentDispatch[eax*4]
	   00000000 R

 0000012C  F7 D9		B400:   neg     ecx
				        ; Dispatch to different codes depending on src alignment
 0000012E  FF 24 85		        jmp     AlignmentDispatchNT[eax*4]
	   00000080 R

				ELSE    ; Position-independent code
				ENDIF

				align   16
 00000140			C100:   ; Code for aligned src. SSE2 or later instruction set
				        ; The nice case, src and dest have same alignment.

				        ; Loop. ecx has negative index from the end, counting up to zero
 00000140  0F 28 04 31		        movaps  xmm0, [esi+ecx]
 00000144  0F 28 4C 31 10	        movaps  xmm1, [esi+ecx+10H]
 00000149  0F 29 04 39		        movaps  [edi+ecx], xmm0
 0000014D  0F 29 4C 39 10	        movaps  [edi+ecx+10H], xmm1
 00000152  83 C1 20		        add     ecx, 20H
 00000155  75 E9		        jnz     C100
				        
				        ; Move the remaining edx bytes (0 - 31):
 00000157  03 F2		        add     esi, edx
 00000159  03 FA		        add     edi, edx
 0000015B  F7 DA		        neg     edx
 0000015D  74 4E		        jz      C500                   ; Skip if no more data
				        ; move 16-8-4-2-1 bytes, aligned
 0000015F  83 FA F0		        cmp     edx, -10H
 00000162  7F 0B		        jg      C200
				        ; move 16 bytes
 00000164  0F 28 04 32		        movaps  xmm0, [esi+edx]
 00000168  0F 29 04 3A		        movaps  [edi+edx], xmm0
 0000016C  83 C2 10		        add     edx, 10H
 0000016F  83 FA F8		C200:   cmp     edx, -8
 00000172  7F 0F		        jg      C210        
				        ; move 8 bytes
 00000174  F3/ 0F 7E 04 32	        movq    xmm0, qword ptr [esi+edx]
 00000179  66| 0F D6 04 3A	        movq    qword ptr [edi+edx], xmm0
 0000017E  83 C2 08		        add     edx, 8 
 00000181  74 2A		        jz      C500                   ; Early skip if count divisible by 8       
 00000183  83 FA FC		C210:   cmp     edx, -4
 00000186  7F 09		        jg      C220        
				        ; move 4 bytes
 00000188  8B 04 32		        mov     eax, [esi+edx]
 0000018B  89 04 3A		        mov     [edi+edx], eax
 0000018E  83 C2 04		        add     edx, 4        
 00000191  83 FA FE		C220:   cmp     edx, -2
 00000194  7F 0B		        jg      C230        
				        ; move 2 bytes
 00000196  0F B7 04 32		        movzx   eax, word ptr [esi+edx]
 0000019A  66| 89 04 3A		        mov     [edi+edx], ax
 0000019E  83 C2 02		        add     edx, 2
 000001A1  83 FA FF		C230:   cmp     edx, -1
 000001A4  7F 07		        jg      C500        
				        ; move 1 byte
 000001A6  0F B6 04 32		        movzx   eax, byte ptr [esi+edx]
 000001AA  88 04 3A		        mov     [edi+edx], al
 000001AD			C500:   ; finished     
				        RETURNM
 000001AD  5F		     1	        pop     edi
 000001AE  5E		     1	        pop     esi
 000001AF  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 000001B3  C3		     1	        ret
				        
				       
				; Code for each src alignment, SSE2 instruction set:
				; Make separate code for each alignment u because the shift instructions
				; have the shift count as a constant:

				MOVE_UNALIGNED_SSE2 MACRO u, nt
				; Move ecx + edx bytes of data
				; Source is misaligned. (src-dest) modulo 16 = u
				; nt = 1 if non-temporal store desired
				; eax = u
				; esi = src - u = nearest preceding 16-bytes boundary
				; edi = dest (aligned)
				; ecx = - (count rounded down to nearest divisible by 32)
				; edx = remaining bytes to move after loop
				LOCAL L1, L2
				        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
				L1:    ; Loop. ecx has negative index from the end, counting up to zero
				        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        movdqa  xmm2, [esi+ecx+20H]
				        movdqa  xmm3, xmm1             ; Copy because used twice
				        psrldq  xmm0, u                ; shift right
				        pslldq  xmm1, 16-u             ; shift left
				        por     xmm0, xmm1             ; combine blocks
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm0        ; non-temporal save
				        ENDIF
				        movdqa  xmm0, xmm2             ; Save for next iteration
				        psrldq  xmm3, u                ; shift right
				        pslldq  xmm2, 16-u             ; shift left
				        por     xmm3, xmm2             ; combine blocks
				        IF nt eq 0
				        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
				        ELSE
				        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
				        ENDIF
				        add     ecx, 20H               ; Loop through negative values up to zero
				        jnz     L1
				        
				        ; Set up for edx remaining bytes
				        add     esi, edx
				        add     edi, edx
				        neg     edx
				        cmp     edx, -10H
				        jg      L2
				        ; One more 16-bytes block to move
				        movdqa  xmm1, [esi+edx+10H]
				        psrldq  xmm0, u                ; shift right
				        pslldq  xmm1, 16-u             ; shift left
				        por     xmm0, xmm1             ; combine blocks
				        IF nt eq 0
				        movdqa  [edi+edx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+edx], xmm0        ; non-temporal save
				        ENDIF        
				        add     edx, 10H        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM

				MOVE_UNALIGNED_SSE2_4 MACRO nt
				; Special case for u = 4
				LOCAL L1, L2
				        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
				L1:     ; Loop. ecx has negative index from the end, counting up to zero
				        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        movss   xmm0, xmm1             ; Moves 4 bytes, leaves remaining bytes unchanged
				        pshufd  xmm0, xmm0, 00111001B
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm0        ; Non-temporal save
				        ENDIF
				        movaps  xmm0, [esi+ecx+20H]
				        movss   xmm1, xmm0
				        pshufd  xmm1, xmm1, 00111001B
				        IF nt eq 0
				        movdqa  [edi+ecx+10H], xmm1    ; Save aligned
				        ELSE
				        movntdq [edi+ecx+10H], xmm1    ; Non-temporal save
				        ENDIF
				        add     ecx, 20H               ; Loop through negative values up to zero
				        jnz     L1        
				        ; Set up for edx remaining bytes
				        add     esi, edx
				        add     edi, edx
				        neg     edx
				        cmp     edx, -10H
				        jg      L2
				        ; One more 16-bytes block to move
				        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
				        movss   xmm0, xmm1
				        pshufd  xmm0, xmm0, 00111001B
				        IF nt eq 0
				        movdqa  [edi+edx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+edx], xmm0        ; Non-temporal save
				        ENDIF
				        add     edx, 10H        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM 

				MOVE_UNALIGNED_SSE2_8 MACRO nt
				; Special case for u = 8
				LOCAL L1, L2
				        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
				L1:     ; Loop. ecx has negative index from the end, counting up to zero
				        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        movsd   xmm0, xmm1             ; Moves 8 bytes, leaves remaining bytes unchanged
				        shufps  xmm0, xmm0, 01001110B  ; Rotate
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm0        ; Non-temporal save
				        ENDIF
				        movaps  xmm0, [esi+ecx+20H]
				        movsd   xmm1, xmm0
				        shufps  xmm1, xmm1, 01001110B
				        IF nt eq 0
				        movdqa  [edi+ecx+10H], xmm1    ; Save aligned
				        ELSE
				        movntdq [edi+ecx+10H], xmm1    ; Non-temporal save
				        ENDIF
				        add     ecx, 20H               ; Loop through negative values up to zero
				        jnz     L1        
				        ; Set up for edx remaining bytes
				        add     esi, edx
				        add     edi, edx
				        neg     edx
				        cmp     edx, -10H
				        jg      L2
				        ; One more 16-bytes block to move
				        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
				        movsd   xmm0, xmm1
				        shufps  xmm0, xmm0, 01001110B
				        IF nt eq 0
				        movdqa  [edi+edx], xmm0        ; Save aligned
				        ELSE
				        movntdq [edi+edx], xmm0        ; Non-temporal save
				        ENDIF
				        add     edx, 10H        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM 

				MOVE_UNALIGNED_SSE2_12 MACRO nt
				; Special case for u = 12
				LOCAL L1, L2
				        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
				        pshufd  xmm0, xmm0, 10010011B
				L1:     ; Loop. ecx has negative index from the end, counting up to zero
				        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
				        movaps  xmm2, [esi+ecx+20H]
				        pshufd  xmm1, xmm1, 10010011B
				        pshufd  xmm2, xmm2, 10010011B
				        movaps  xmm3, xmm2
				        movss   xmm2, xmm1             ; Moves 4 bytes, leaves remaining bytes unchanged
				        movss   xmm1, xmm0             ; Moves 4 bytes, leaves remaining bytes unchanged       
				        IF nt eq 0
				        movdqa  [edi+ecx], xmm1        ; Save aligned
				        movdqa  [edi+ecx+10H], xmm2    ; Save aligned
				        ELSE
				        movntdq [edi+ecx], xmm1        ; Non-temporal save
				        movntdq [edi+ecx+10H], xmm2    ; Non-temporal save
				        ENDIF
				        movaps  xmm0, xmm3             ; Save for next iteration        
				        add     ecx, 20H               ; Loop through negative values up to zero
				        jnz     L1        
				        ; Set up for edx remaining bytes
				        add     esi, edx
				        add     edi, edx
				        neg     edx
				        cmp     edx, -10H
				        jg      L2
				        ; One more 16-bytes block to move
				        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
				        pshufd  xmm1, xmm1, 10010011B
				        movss   xmm1, xmm0             ; Moves 4 bytes, leaves remaining bytes unchanged       
				        IF nt eq 0
				        movdqa  [edi+edx], xmm1        ; Save aligned
				        ELSE
				        movntdq [edi+edx], xmm1        ; Non-temporal save
				        ENDIF
				        add     edx, 10H        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes, unaligned
				        jmp     C200
				ENDM 

				; Code for each src alignment, Suppl.SSE3 instruction set:
				; Make separate code for each alignment u because the palignr instruction
				; has the shift count as a constant:

				MOVE_UNALIGNED_SSSE3 MACRO u
				; Move ecx + edx bytes of data
				; Source is misaligned. (src-dest) modulo 16 = u
				; eax = u
				; esi = src - u = nearest preceding 16-bytes boundary
				; edi = dest (aligned)
				; ecx = - (count rounded down to nearest divisible by 32)
				; edx = remaining bytes to move after loop
				LOCAL L1, L2
				        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
				        
				L1:     ; Loop. ecx has negative index from the end, counting up to zero
				        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
				        movdqa  xmm3, [esi+ecx+20H]
				        movdqa  xmm1, xmm0             ; Save xmm0
				        movdqa  xmm0, xmm3             ; Save for next iteration
				        palignr xmm3, xmm2, u          ; Combine parts into aligned block
				        palignr xmm2, xmm1, u          ; Combine parts into aligned block
				        movdqa  [edi+ecx], xmm2        ; Save aligned
				        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
				        add     ecx, 20H
				        jnz     L1
				        
				        ; Set up for edx remaining bytes
				        add     esi, edx
				        add     edi, edx
				        neg     edx
				        cmp     edx, -10H
				        jg      L2
				        ; One more 16-bytes block to move
				        movdqa  xmm2, [esi+edx+10H]
				        palignr xmm2, xmm0, u
				        movdqa  [edi+edx], xmm2
				        add     edx, 10H        
				L2:     ; Get src pointer back to misaligned state
				        add     esi, eax
				        ; Move remaining 0 - 15 bytes
				        jmp     C200
				ENDM        

				; Make 15 instances of SSE2 macro for each value of the alignment u.
				; These are pointed to by the jump table AlignmentDispatchSSE2 below
				; (aligns are inserted manually to minimize the number of 16-bytes
				; boundaries inside loops)

 000001B4			D101:   MOVE_UNALIGNED_SSE2 1,   0
 000001B4  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000001B9		     1	??0000:    ; Loop. ecx has negative index from the end, counting up to zero
 000001B9  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000001BF  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000001C5  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000001C9  66| 0F 73 D8	     1	        psrldq  xmm0, 1                ; shift right
	   01
 000001CE  66| 0F 73 F9	     1	        pslldq  xmm1, 16-1             ; shift left
	   0F
 000001D3  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000001D7  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000001DC  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000001E0  66| 0F 73 DB	     1	        psrldq  xmm3, 1                ; shift right
	   01
 000001E5  66| 0F 73 FA	     1	        pslldq  xmm2, 16-1             ; shift left
	   0F
 000001EA  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000001EE  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 000001F4  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000001F7  75 C0	     1	        jnz     ??0000
 000001F9  03 F2	     1	        add     esi, edx
 000001FB  03 FA	     1	        add     edi, edx
 000001FD  F7 DA	     1	        neg     edx
 000001FF  83 FA F0	     1	        cmp     edx, -10H
 00000202  7F 1C	     1	        jg      ??0001
 00000204  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 0000020A  66| 0F 73 D8	     1	        psrldq  xmm0, 1                ; shift right
	   01
 0000020F  66| 0F 73 F9	     1	        pslldq  xmm1, 16-1             ; shift left
	   0F
 00000214  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000218  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 0000021D  83 C2 10	     1	        add     edx, 10H        
 00000220		     1	??0001:     ; Get src pointer back to misaligned state
 00000220  03 F0	     1	        add     esi, eax
 00000222  E9 FFFFFF48	     1	        jmp     C200
 00000227			D102:   MOVE_UNALIGNED_SSE2 2,   0
 00000227  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 0000022C		     1	??0002:    ; Loop. ecx has negative index from the end, counting up to zero
 0000022C  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000232  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000238  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 0000023C  66| 0F 73 D8	     1	        psrldq  xmm0, 2                ; shift right
	   02
 00000241  66| 0F 73 F9	     1	        pslldq  xmm1, 16-2             ; shift left
	   0E
 00000246  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000024A  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 0000024F  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000253  66| 0F 73 DB	     1	        psrldq  xmm3, 2                ; shift right
	   02
 00000258  66| 0F 73 FA	     1	        pslldq  xmm2, 16-2             ; shift left
	   0E
 0000025D  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000261  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000267  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 0000026A  75 C0	     1	        jnz     ??0002
 0000026C  03 F2	     1	        add     esi, edx
 0000026E  03 FA	     1	        add     edi, edx
 00000270  F7 DA	     1	        neg     edx
 00000272  83 FA F0	     1	        cmp     edx, -10H
 00000275  7F 1C	     1	        jg      ??0003
 00000277  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 0000027D  66| 0F 73 D8	     1	        psrldq  xmm0, 2                ; shift right
	   02
 00000282  66| 0F 73 F9	     1	        pslldq  xmm1, 16-2             ; shift left
	   0E
 00000287  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000028B  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 00000290  83 C2 10	     1	        add     edx, 10H        
 00000293		     1	??0003:     ; Get src pointer back to misaligned state
 00000293  03 F0	     1	        add     esi, eax
 00000295  E9 FFFFFED5	     1	        jmp     C200
 0000029A			D103:   MOVE_UNALIGNED_SSE2 3,   0
 0000029A  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 0000029F		     1	??0004:    ; Loop. ecx has negative index from the end, counting up to zero
 0000029F  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000002A5  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000002AB  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000002AF  66| 0F 73 D8	     1	        psrldq  xmm0, 3                ; shift right
	   03
 000002B4  66| 0F 73 F9	     1	        pslldq  xmm1, 16-3             ; shift left
	   0D
 000002B9  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000002BD  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000002C2  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000002C6  66| 0F 73 DB	     1	        psrldq  xmm3, 3                ; shift right
	   03
 000002CB  66| 0F 73 FA	     1	        pslldq  xmm2, 16-3             ; shift left
	   0D
 000002D0  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000002D4  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 000002DA  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000002DD  75 C0	     1	        jnz     ??0004
 000002DF  03 F2	     1	        add     esi, edx
 000002E1  03 FA	     1	        add     edi, edx
 000002E3  F7 DA	     1	        neg     edx
 000002E5  83 FA F0	     1	        cmp     edx, -10H
 000002E8  7F 1C	     1	        jg      ??0005
 000002EA  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 000002F0  66| 0F 73 D8	     1	        psrldq  xmm0, 3                ; shift right
	   03
 000002F5  66| 0F 73 F9	     1	        pslldq  xmm1, 16-3             ; shift left
	   0D
 000002FA  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000002FE  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 00000303  83 C2 10	     1	        add     edx, 10H        
 00000306		     1	??0005:     ; Get src pointer back to misaligned state
 00000306  03 F0	     1	        add     esi, eax
 00000308  E9 FFFFFE62	     1	        jmp     C200
				align   16
 00000310			D104:   MOVE_UNALIGNED_SSE2_4    0
 00000310  0F 28 04 31	     1	        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000314		     1	??0006:     ; Loop. ecx has negative index from the end, counting up to zero
 00000314  0F 28 4C 31 10    1	        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
 00000319  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1             ; Moves 4 bytes, leaves remaining bytes unchanged
 0000031D  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 00111001B
	   39
 00000322  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000327  0F 28 44 31 20    1	        movaps  xmm0, [esi+ecx+20H]
 0000032C  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0
 00000330  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 00111001B
	   39
 00000335  66| 0F 7F 4C 39   1	        movdqa  [edi+ecx+10H], xmm1    ; Save aligned
	   10
 0000033B  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 0000033E  75 D4	     1	        jnz     ??0006        
 00000340  03 F2	     1	        add     esi, edx
 00000342  03 FA	     1	        add     edi, edx
 00000344  F7 DA	     1	        neg     edx
 00000346  83 FA F0	     1	        cmp     edx, -10H
 00000349  7F 16	     1	        jg      ??0007
 0000034B  0F 28 4C 32 10    1	        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
 00000350  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1
 00000354  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 00111001B
	   39
 00000359  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 0000035E  83 C2 10	     1	        add     edx, 10H        
 00000361		     1	??0007:     ; Get src pointer back to misaligned state
 00000361  03 F0	     1	        add     esi, eax
 00000363  E9 FFFFFE07	     1	        jmp     C200
 00000368			D105:   MOVE_UNALIGNED_SSE2 5,   0
 00000368  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 0000036D		     1	??0008:    ; Loop. ecx has negative index from the end, counting up to zero
 0000036D  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000373  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000379  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 0000037D  66| 0F 73 D8	     1	        psrldq  xmm0, 5                ; shift right
	   05
 00000382  66| 0F 73 F9	     1	        pslldq  xmm1, 16-5             ; shift left
	   0B
 00000387  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000038B  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000390  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000394  66| 0F 73 DB	     1	        psrldq  xmm3, 5                ; shift right
	   05
 00000399  66| 0F 73 FA	     1	        pslldq  xmm2, 16-5             ; shift left
	   0B
 0000039E  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000003A2  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 000003A8  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000003AB  75 C0	     1	        jnz     ??0008
 000003AD  03 F2	     1	        add     esi, edx
 000003AF  03 FA	     1	        add     edi, edx
 000003B1  F7 DA	     1	        neg     edx
 000003B3  83 FA F0	     1	        cmp     edx, -10H
 000003B6  7F 1C	     1	        jg      ??0009
 000003B8  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 000003BE  66| 0F 73 D8	     1	        psrldq  xmm0, 5                ; shift right
	   05
 000003C3  66| 0F 73 F9	     1	        pslldq  xmm1, 16-5             ; shift left
	   0B
 000003C8  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000003CC  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 000003D1  83 C2 10	     1	        add     edx, 10H        
 000003D4		     1	??0009:     ; Get src pointer back to misaligned state
 000003D4  03 F0	     1	        add     esi, eax
 000003D6  E9 FFFFFD94	     1	        jmp     C200
 000003DB			D106:   MOVE_UNALIGNED_SSE2 6,   0
 000003DB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000003E0		     1	??000A:    ; Loop. ecx has negative index from the end, counting up to zero
 000003E0  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000003E6  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000003EC  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000003F0  66| 0F 73 D8	     1	        psrldq  xmm0, 6                ; shift right
	   06
 000003F5  66| 0F 73 F9	     1	        pslldq  xmm1, 16-6             ; shift left
	   0A
 000003FA  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000003FE  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000403  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000407  66| 0F 73 DB	     1	        psrldq  xmm3, 6                ; shift right
	   06
 0000040C  66| 0F 73 FA	     1	        pslldq  xmm2, 16-6             ; shift left
	   0A
 00000411  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000415  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 0000041B  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 0000041E  75 C0	     1	        jnz     ??000A
 00000420  03 F2	     1	        add     esi, edx
 00000422  03 FA	     1	        add     edi, edx
 00000424  F7 DA	     1	        neg     edx
 00000426  83 FA F0	     1	        cmp     edx, -10H
 00000429  7F 1C	     1	        jg      ??000B
 0000042B  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00000431  66| 0F 73 D8	     1	        psrldq  xmm0, 6                ; shift right
	   06
 00000436  66| 0F 73 F9	     1	        pslldq  xmm1, 16-6             ; shift left
	   0A
 0000043B  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000043F  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 00000444  83 C2 10	     1	        add     edx, 10H        
 00000447		     1	??000B:     ; Get src pointer back to misaligned state
 00000447  03 F0	     1	        add     esi, eax
 00000449  E9 FFFFFD21	     1	        jmp     C200
				align   8
 00000450			D107:   MOVE_UNALIGNED_SSE2 7,   0
 00000450  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000455		     1	??000C:    ; Loop. ecx has negative index from the end, counting up to zero
 00000455  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 0000045B  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000461  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000465  66| 0F 73 D8	     1	        psrldq  xmm0, 7                ; shift right
	   07
 0000046A  66| 0F 73 F9	     1	        pslldq  xmm1, 16-7             ; shift left
	   09
 0000046F  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000473  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000478  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000047C  66| 0F 73 DB	     1	        psrldq  xmm3, 7                ; shift right
	   07
 00000481  66| 0F 73 FA	     1	        pslldq  xmm2, 16-7             ; shift left
	   09
 00000486  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 0000048A  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000490  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000493  75 C0	     1	        jnz     ??000C
 00000495  03 F2	     1	        add     esi, edx
 00000497  03 FA	     1	        add     edi, edx
 00000499  F7 DA	     1	        neg     edx
 0000049B  83 FA F0	     1	        cmp     edx, -10H
 0000049E  7F 1C	     1	        jg      ??000D
 000004A0  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 000004A6  66| 0F 73 D8	     1	        psrldq  xmm0, 7                ; shift right
	   07
 000004AB  66| 0F 73 F9	     1	        pslldq  xmm1, 16-7             ; shift left
	   09
 000004B0  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000004B4  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 000004B9  83 C2 10	     1	        add     edx, 10H        
 000004BC		     1	??000D:     ; Get src pointer back to misaligned state
 000004BC  03 F0	     1	        add     esi, eax
 000004BE  E9 FFFFFCAC	     1	        jmp     C200
				align   16
 000004D0			D108:   MOVE_UNALIGNED_SSE2_8    0
 000004D0  0F 28 04 31	     1	        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000004D4		     1	??000E:     ; Loop. ecx has negative index from the end, counting up to zero
 000004D4  0F 28 4C 31 10    1	        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
 000004D9  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1             ; Moves 8 bytes, leaves remaining bytes unchanged
 000004DD  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B  ; Rotate
 000004E1  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000004E6  0F 28 44 31 20    1	        movaps  xmm0, [esi+ecx+20H]
 000004EB  F2/ 0F 10 C8	     1	        movsd   xmm1, xmm0
 000004EF  0F C6 C9 4E	     1	        shufps  xmm1, xmm1, 01001110B
 000004F3  66| 0F 7F 4C 39   1	        movdqa  [edi+ecx+10H], xmm1    ; Save aligned
	   10
 000004F9  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000004FC  75 D6	     1	        jnz     ??000E        
 000004FE  03 F2	     1	        add     esi, edx
 00000500  03 FA	     1	        add     edi, edx
 00000502  F7 DA	     1	        neg     edx
 00000504  83 FA F0	     1	        cmp     edx, -10H
 00000507  7F 15	     1	        jg      ??000F
 00000509  0F 28 4C 32 10    1	        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
 0000050E  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1
 00000512  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B
 00000516  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 0000051B  83 C2 10	     1	        add     edx, 10H        
 0000051E		     1	??000F:     ; Get src pointer back to misaligned state
 0000051E  03 F0	     1	        add     esi, eax
 00000520  E9 FFFFFC4A	     1	        jmp     C200
 00000525			D109:   MOVE_UNALIGNED_SSE2 9,   0
 00000525  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 0000052A		     1	??0010:    ; Loop. ecx has negative index from the end, counting up to zero
 0000052A  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000530  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000536  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 0000053A  66| 0F 73 D8	     1	        psrldq  xmm0, 9                ; shift right
	   09
 0000053F  66| 0F 73 F9	     1	        pslldq  xmm1, 16-9             ; shift left
	   07
 00000544  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000548  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 0000054D  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000551  66| 0F 73 DB	     1	        psrldq  xmm3, 9                ; shift right
	   09
 00000556  66| 0F 73 FA	     1	        pslldq  xmm2, 16-9             ; shift left
	   07
 0000055B  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 0000055F  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000565  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000568  75 C0	     1	        jnz     ??0010
 0000056A  03 F2	     1	        add     esi, edx
 0000056C  03 FA	     1	        add     edi, edx
 0000056E  F7 DA	     1	        neg     edx
 00000570  83 FA F0	     1	        cmp     edx, -10H
 00000573  7F 1C	     1	        jg      ??0011
 00000575  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 0000057B  66| 0F 73 D8	     1	        psrldq  xmm0, 9                ; shift right
	   09
 00000580  66| 0F 73 F9	     1	        pslldq  xmm1, 16-9             ; shift left
	   07
 00000585  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000589  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 0000058E  83 C2 10	     1	        add     edx, 10H        
 00000591		     1	??0011:     ; Get src pointer back to misaligned state
 00000591  03 F0	     1	        add     esi, eax
 00000593  E9 FFFFFBD7	     1	        jmp     C200
 00000598			D10A:   MOVE_UNALIGNED_SSE2 0AH, 0
 00000598  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 0000059D		     1	??0012:    ; Loop. ecx has negative index from the end, counting up to zero
 0000059D  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000005A3  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000005A9  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000005AD  66| 0F 73 D8	     1	        psrldq  xmm0, 0AH                ; shift right
	   0A
 000005B2  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0AH             ; shift left
	   06
 000005B7  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000005BB  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000005C0  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000005C4  66| 0F 73 DB	     1	        psrldq  xmm3, 0AH                ; shift right
	   0A
 000005C9  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0AH             ; shift left
	   06
 000005CE  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000005D2  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 000005D8  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000005DB  75 C0	     1	        jnz     ??0012
 000005DD  03 F2	     1	        add     esi, edx
 000005DF  03 FA	     1	        add     edi, edx
 000005E1  F7 DA	     1	        neg     edx
 000005E3  83 FA F0	     1	        cmp     edx, -10H
 000005E6  7F 1C	     1	        jg      ??0013
 000005E8  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 000005EE  66| 0F 73 D8	     1	        psrldq  xmm0, 0AH                ; shift right
	   0A
 000005F3  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0AH             ; shift left
	   06
 000005F8  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000005FC  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 00000601  83 C2 10	     1	        add     edx, 10H        
 00000604		     1	??0013:     ; Get src pointer back to misaligned state
 00000604  03 F0	     1	        add     esi, eax
 00000606  E9 FFFFFB64	     1	        jmp     C200
 0000060B			D10B:   MOVE_UNALIGNED_SSE2 0BH, 0
 0000060B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000610		     1	??0014:    ; Loop. ecx has negative index from the end, counting up to zero
 00000610  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000616  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 0000061C  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000620  66| 0F 73 D8	     1	        psrldq  xmm0, 0BH                ; shift right
	   0B
 00000625  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0BH             ; shift left
	   05
 0000062A  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000062E  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 00000633  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000637  66| 0F 73 DB	     1	        psrldq  xmm3, 0BH                ; shift right
	   0B
 0000063C  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0BH             ; shift left
	   05
 00000641  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000645  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 0000064B  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 0000064E  75 C0	     1	        jnz     ??0014
 00000650  03 F2	     1	        add     esi, edx
 00000652  03 FA	     1	        add     edi, edx
 00000654  F7 DA	     1	        neg     edx
 00000656  83 FA F0	     1	        cmp     edx, -10H
 00000659  7F 1C	     1	        jg      ??0015
 0000065B  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00000661  66| 0F 73 D8	     1	        psrldq  xmm0, 0BH                ; shift right
	   0B
 00000666  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0BH             ; shift left
	   05
 0000066B  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000066F  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 00000674  83 C2 10	     1	        add     edx, 10H        
 00000677		     1	??0015:     ; Get src pointer back to misaligned state
 00000677  03 F0	     1	        add     esi, eax
 00000679  E9 FFFFFAF1	     1	        jmp     C200
				align   8
 00000680			D10C:   MOVE_UNALIGNED_SSE2_12   0
 00000680  0F 28 04 31	     1	        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000684  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 10010011B
	   93
 00000689		     1	??0016:     ; Loop. ecx has negative index from the end, counting up to zero
 00000689  0F 28 4C 31 10    1	        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
 0000068E  0F 28 54 31 20    1	        movaps  xmm2, [esi+ecx+20H]
 00000693  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B
	   93
 00000698  66| 0F 70 D2	     1	        pshufd  xmm2, xmm2, 10010011B
	   93
 0000069D  0F 28 DA	     1	        movaps  xmm3, xmm2
 000006A0  F3/ 0F 10 D1	     1	        movss   xmm2, xmm1             ; Moves 4 bytes, leaves remaining bytes unchanged
 000006A4  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0             ; Moves 4 bytes, leaves remaining bytes unchanged       
 000006A8  66| 0F 7F 0C 39   1	        movdqa  [edi+ecx], xmm1        ; Save aligned
 000006AD  66| 0F 7F 54 39   1	        movdqa  [edi+ecx+10H], xmm2    ; Save aligned
	   10
 000006B3  0F 28 C3	     1	        movaps  xmm0, xmm3             ; Save for next iteration        
 000006B6  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000006B9  75 CE	     1	        jnz     ??0016        
 000006BB  03 F2	     1	        add     esi, edx
 000006BD  03 FA	     1	        add     edi, edx
 000006BF  F7 DA	     1	        neg     edx
 000006C1  83 FA F0	     1	        cmp     edx, -10H
 000006C4  7F 16	     1	        jg      ??0017
 000006C6  0F 28 4C 32 10    1	        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
 000006CB  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B
	   93
 000006D0  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0             ; Moves 4 bytes, leaves remaining bytes unchanged       
 000006D4  66| 0F 7F 0C 3A   1	        movdqa  [edi+edx], xmm1        ; Save aligned
 000006D9  83 C2 10	     1	        add     edx, 10H        
 000006DC		     1	??0017:     ; Get src pointer back to misaligned state
 000006DC  03 F0	     1	        add     esi, eax
 000006DE  E9 FFFFFA8C	     1	        jmp     C200
 000006E3			D10D:   MOVE_UNALIGNED_SSE2 0DH, 0
 000006E3  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000006E8		     1	??0018:    ; Loop. ecx has negative index from the end, counting up to zero
 000006E8  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000006EE  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000006F4  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000006F8  66| 0F 73 D8	     1	        psrldq  xmm0, 0DH                ; shift right
	   0D
 000006FD  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0DH             ; shift left
	   03
 00000702  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000706  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 0000070B  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000070F  66| 0F 73 DB	     1	        psrldq  xmm3, 0DH                ; shift right
	   0D
 00000714  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0DH             ; shift left
	   03
 00000719  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 0000071D  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000723  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000726  75 C0	     1	        jnz     ??0018
 00000728  03 F2	     1	        add     esi, edx
 0000072A  03 FA	     1	        add     edi, edx
 0000072C  F7 DA	     1	        neg     edx
 0000072E  83 FA F0	     1	        cmp     edx, -10H
 00000731  7F 1C	     1	        jg      ??0019
 00000733  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00000739  66| 0F 73 D8	     1	        psrldq  xmm0, 0DH                ; shift right
	   0D
 0000073E  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0DH             ; shift left
	   03
 00000743  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000747  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 0000074C  83 C2 10	     1	        add     edx, 10H        
 0000074F		     1	??0019:     ; Get src pointer back to misaligned state
 0000074F  03 F0	     1	        add     esi, eax
 00000751  E9 FFFFFA19	     1	        jmp     C200
 00000756			D10E:   MOVE_UNALIGNED_SSE2 0EH, 0
 00000756  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 0000075B		     1	??001A:    ; Loop. ecx has negative index from the end, counting up to zero
 0000075B  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000761  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000767  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 0000076B  66| 0F 73 D8	     1	        psrldq  xmm0, 0EH                ; shift right
	   0E
 00000770  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0EH             ; shift left
	   02
 00000775  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000779  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 0000077E  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000782  66| 0F 73 DB	     1	        psrldq  xmm3, 0EH                ; shift right
	   0E
 00000787  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0EH             ; shift left
	   02
 0000078C  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000790  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000796  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000799  75 C0	     1	        jnz     ??001A
 0000079B  03 F2	     1	        add     esi, edx
 0000079D  03 FA	     1	        add     edi, edx
 0000079F  F7 DA	     1	        neg     edx
 000007A1  83 FA F0	     1	        cmp     edx, -10H
 000007A4  7F 1C	     1	        jg      ??001B
 000007A6  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 000007AC  66| 0F 73 D8	     1	        psrldq  xmm0, 0EH                ; shift right
	   0E
 000007B1  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0EH             ; shift left
	   02
 000007B6  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000007BA  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 000007BF  83 C2 10	     1	        add     edx, 10H        
 000007C2		     1	??001B:     ; Get src pointer back to misaligned state
 000007C2  03 F0	     1	        add     esi, eax
 000007C4  E9 FFFFF9A6	     1	        jmp     C200
 000007C9			D10F:   MOVE_UNALIGNED_SSE2 0FH, 0
 000007C9  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000007CE		     1	??001C:    ; Loop. ecx has negative index from the end, counting up to zero
 000007CE  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000007D4  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000007DA  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000007DE  66| 0F 73 D8	     1	        psrldq  xmm0, 0FH                ; shift right
	   0F
 000007E3  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0FH             ; shift left
	   01
 000007E8  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000007EC  66| 0F 7F 04 39   1	        movdqa  [edi+ecx], xmm0        ; Save aligned
 000007F1  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000007F5  66| 0F 73 DB	     1	        psrldq  xmm3, 0FH                ; shift right
	   0F
 000007FA  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0FH             ; shift left
	   01
 000007FF  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000803  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000809  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 0000080C  75 C0	     1	        jnz     ??001C
 0000080E  03 F2	     1	        add     esi, edx
 00000810  03 FA	     1	        add     edi, edx
 00000812  F7 DA	     1	        neg     edx
 00000814  83 FA F0	     1	        cmp     edx, -10H
 00000817  7F 1C	     1	        jg      ??001D
 00000819  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 0000081F  66| 0F 73 D8	     1	        psrldq  xmm0, 0FH                ; shift right
	   0F
 00000824  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0FH             ; shift left
	   01
 00000829  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000082D  66| 0F 7F 04 3A   1	        movdqa  [edi+edx], xmm0        ; Save aligned
 00000832  83 C2 10	     1	        add     edx, 10H        
 00000835		     1	??001D:     ; Get src pointer back to misaligned state
 00000835  03 F0	     1	        add     esi, eax
 00000837  E9 FFFFF933	     1	        jmp     C200
				        
				; Make 15 instances of Suppl-SSE3 macro for each value of the alignment u.
				; These are pointed to by the jump table AlignmentDispatchSupSSE3 below

				align   8
 00000840			E101:   MOVE_UNALIGNED_SSSE3 1
 00000840  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000845		     1	??001E:     ; Loop. ecx has negative index from the end, counting up to zero
 00000845  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 0000084B  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000851  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000855  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000859  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 1          ; Combine parts into aligned block
	   01
 0000085F  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 1          ; Combine parts into aligned block
	   01
 00000865  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 0000086A  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000870  83 C1 20	     1	        add     ecx, 20H
 00000873  75 D0	     1	        jnz     ??001E
 00000875  03 F2	     1	        add     esi, edx
 00000877  03 FA	     1	        add     edi, edx
 00000879  F7 DA	     1	        neg     edx
 0000087B  83 FA F0	     1	        cmp     edx, -10H
 0000087E  7F 14	     1	        jg      ??001F
 00000880  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000886  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 1
	   01
 0000088C  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000891  83 C2 10	     1	        add     edx, 10H        
 00000894		     1	??001F:     ; Get src pointer back to misaligned state
 00000894  03 F0	     1	        add     esi, eax
 00000896  E9 FFFFF8D4	     1	        jmp     C200
 0000089B			E102:   MOVE_UNALIGNED_SSSE3 2
 0000089B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000008A0		     1	??0020:     ; Loop. ecx has negative index from the end, counting up to zero
 000008A0  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 000008A6  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 000008AC  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 000008B0  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 000008B4  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 2          ; Combine parts into aligned block
	   02
 000008BA  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 2          ; Combine parts into aligned block
	   02
 000008C0  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 000008C5  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 000008CB  83 C1 20	     1	        add     ecx, 20H
 000008CE  75 D0	     1	        jnz     ??0020
 000008D0  03 F2	     1	        add     esi, edx
 000008D2  03 FA	     1	        add     edi, edx
 000008D4  F7 DA	     1	        neg     edx
 000008D6  83 FA F0	     1	        cmp     edx, -10H
 000008D9  7F 14	     1	        jg      ??0021
 000008DB  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 000008E1  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 2
	   02
 000008E7  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 000008EC  83 C2 10	     1	        add     edx, 10H        
 000008EF		     1	??0021:     ; Get src pointer back to misaligned state
 000008EF  03 F0	     1	        add     esi, eax
 000008F1  E9 FFFFF879	     1	        jmp     C200
 000008F6			E103:   MOVE_UNALIGNED_SSSE3 3
 000008F6  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000008FB		     1	??0022:     ; Loop. ecx has negative index from the end, counting up to zero
 000008FB  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000901  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000907  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 0000090B  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 0000090F  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 3          ; Combine parts into aligned block
	   03
 00000915  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 3          ; Combine parts into aligned block
	   03
 0000091B  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000920  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000926  83 C1 20	     1	        add     ecx, 20H
 00000929  75 D0	     1	        jnz     ??0022
 0000092B  03 F2	     1	        add     esi, edx
 0000092D  03 FA	     1	        add     edi, edx
 0000092F  F7 DA	     1	        neg     edx
 00000931  83 FA F0	     1	        cmp     edx, -10H
 00000934  7F 14	     1	        jg      ??0023
 00000936  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 0000093C  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 3
	   03
 00000942  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000947  83 C2 10	     1	        add     edx, 10H        
 0000094A		     1	??0023:     ; Get src pointer back to misaligned state
 0000094A  03 F0	     1	        add     esi, eax
 0000094C  E9 FFFFF81E	     1	        jmp     C200
 00000951			E104:   MOVE_UNALIGNED_SSSE3 4
 00000951  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000956		     1	??0024:     ; Loop. ecx has negative index from the end, counting up to zero
 00000956  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 0000095C  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000962  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000966  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 0000096A  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 4          ; Combine parts into aligned block
	   04 20
 00000970  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 4          ; Combine parts into aligned block
	   04 20
 00000976  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 0000097B  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000981  83 C1 20	     1	        add     ecx, 20H
 00000984  75 D0	     1	        jnz     ??0024
 00000986  03 F2	     1	        add     esi, edx
 00000988  03 FA	     1	        add     edi, edx
 0000098A  F7 DA	     1	        neg     edx
 0000098C  83 FA F0	     1	        cmp     edx, -10H
 0000098F  7F 14	     1	        jg      ??0025
 00000991  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000997  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 4
	   04 20
 0000099D  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 000009A2  83 C2 10	     1	        add     edx, 10H        
 000009A5		     1	??0025:     ; Get src pointer back to misaligned state
 000009A5  03 F0	     1	        add     esi, eax
 000009A7  E9 FFFFF7C3	     1	        jmp     C200
				align   8
 000009B0			E105:   MOVE_UNALIGNED_SSSE3 5
 000009B0  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000009B5		     1	??0026:     ; Loop. ecx has negative index from the end, counting up to zero
 000009B5  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 000009BB  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 000009C1  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 000009C5  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 000009C9  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 5          ; Combine parts into aligned block
	   05
 000009CF  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 5          ; Combine parts into aligned block
	   05
 000009D5  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 000009DA  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 000009E0  83 C1 20	     1	        add     ecx, 20H
 000009E3  75 D0	     1	        jnz     ??0026
 000009E5  03 F2	     1	        add     esi, edx
 000009E7  03 FA	     1	        add     edi, edx
 000009E9  F7 DA	     1	        neg     edx
 000009EB  83 FA F0	     1	        cmp     edx, -10H
 000009EE  7F 14	     1	        jg      ??0027
 000009F0  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 000009F6  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 5
	   05
 000009FC  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000A01  83 C2 10	     1	        add     edx, 10H        
 00000A04		     1	??0027:     ; Get src pointer back to misaligned state
 00000A04  03 F0	     1	        add     esi, eax
 00000A06  E9 FFFFF764	     1	        jmp     C200
 00000A0B			E106:   MOVE_UNALIGNED_SSSE3 6
 00000A0B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000A10		     1	??0028:     ; Loop. ecx has negative index from the end, counting up to zero
 00000A10  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000A16  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000A1C  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000A20  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000A24  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 6          ; Combine parts into aligned block
	   06
 00000A2A  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 6          ; Combine parts into aligned block
	   06
 00000A30  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000A35  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000A3B  83 C1 20	     1	        add     ecx, 20H
 00000A3E  75 D0	     1	        jnz     ??0028
 00000A40  03 F2	     1	        add     esi, edx
 00000A42  03 FA	     1	        add     edi, edx
 00000A44  F7 DA	     1	        neg     edx
 00000A46  83 FA F0	     1	        cmp     edx, -10H
 00000A49  7F 14	     1	        jg      ??0029
 00000A4B  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000A51  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 6
	   06
 00000A57  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000A5C  83 C2 10	     1	        add     edx, 10H        
 00000A5F		     1	??0029:     ; Get src pointer back to misaligned state
 00000A5F  03 F0	     1	        add     esi, eax
 00000A61  E9 FFFFF709	     1	        jmp     C200
 00000A66			E107:   MOVE_UNALIGNED_SSSE3 7
 00000A66  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000A6B		     1	??002A:     ; Loop. ecx has negative index from the end, counting up to zero
 00000A6B  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000A71  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000A77  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000A7B  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000A7F  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 7          ; Combine parts into aligned block
	   07
 00000A85  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 7          ; Combine parts into aligned block
	   07
 00000A8B  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000A90  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000A96  83 C1 20	     1	        add     ecx, 20H
 00000A99  75 D0	     1	        jnz     ??002A
 00000A9B  03 F2	     1	        add     esi, edx
 00000A9D  03 FA	     1	        add     edi, edx
 00000A9F  F7 DA	     1	        neg     edx
 00000AA1  83 FA F0	     1	        cmp     edx, -10H
 00000AA4  7F 14	     1	        jg      ??002B
 00000AA6  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000AAC  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 7
	   07
 00000AB2  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000AB7  83 C2 10	     1	        add     edx, 10H        
 00000ABA		     1	??002B:     ; Get src pointer back to misaligned state
 00000ABA  03 F0	     1	        add     esi, eax
 00000ABC  E9 FFFFF6AE	     1	        jmp     C200
 00000AC1			E108:   MOVE_UNALIGNED_SSSE3 8
 00000AC1  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000AC6		     1	??002C:     ; Loop. ecx has negative index from the end, counting up to zero
 00000AC6  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000ACC  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000AD2  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000AD6  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000ADA  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 8          ; Combine parts into aligned block
	   08
 00000AE0  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 8          ; Combine parts into aligned block
	   08
 00000AE6  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000AEB  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000AF1  83 C1 20	     1	        add     ecx, 20H
 00000AF4  75 D0	     1	        jnz     ??002C
 00000AF6  03 F2	     1	        add     esi, edx
 00000AF8  03 FA	     1	        add     edi, edx
 00000AFA  F7 DA	     1	        neg     edx
 00000AFC  83 FA F0	     1	        cmp     edx, -10H
 00000AFF  7F 14	     1	        jg      ??002D
 00000B01  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000B07  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 8
	   08
 00000B0D  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000B12  83 C2 10	     1	        add     edx, 10H        
 00000B15		     1	??002D:     ; Get src pointer back to misaligned state
 00000B15  03 F0	     1	        add     esi, eax
 00000B17  E9 FFFFF653	     1	        jmp     C200
				align   8
 00000B20			E109:   MOVE_UNALIGNED_SSSE3 9
 00000B20  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000B25		     1	??002E:     ; Loop. ecx has negative index from the end, counting up to zero
 00000B25  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000B2B  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000B31  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000B35  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000B39  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 9          ; Combine parts into aligned block
	   09
 00000B3F  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 9          ; Combine parts into aligned block
	   09
 00000B45  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000B4A  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000B50  83 C1 20	     1	        add     ecx, 20H
 00000B53  75 D0	     1	        jnz     ??002E
 00000B55  03 F2	     1	        add     esi, edx
 00000B57  03 FA	     1	        add     edi, edx
 00000B59  F7 DA	     1	        neg     edx
 00000B5B  83 FA F0	     1	        cmp     edx, -10H
 00000B5E  7F 14	     1	        jg      ??002F
 00000B60  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000B66  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 9
	   09
 00000B6C  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000B71  83 C2 10	     1	        add     edx, 10H        
 00000B74		     1	??002F:     ; Get src pointer back to misaligned state
 00000B74  03 F0	     1	        add     esi, eax
 00000B76  E9 FFFFF5F4	     1	        jmp     C200
 00000B7B			E10A:   MOVE_UNALIGNED_SSSE3 0AH
 00000B7B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000B80		     1	??0030:     ; Loop. ecx has negative index from the end, counting up to zero
 00000B80  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000B86  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000B8C  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000B90  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000B94  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 0AH          ; Combine parts into aligned block
	   0A
 00000B9A  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 0AH          ; Combine parts into aligned block
	   0A
 00000BA0  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000BA5  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000BAB  83 C1 20	     1	        add     ecx, 20H
 00000BAE  75 D0	     1	        jnz     ??0030
 00000BB0  03 F2	     1	        add     esi, edx
 00000BB2  03 FA	     1	        add     edi, edx
 00000BB4  F7 DA	     1	        neg     edx
 00000BB6  83 FA F0	     1	        cmp     edx, -10H
 00000BB9  7F 14	     1	        jg      ??0031
 00000BBB  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000BC1  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 0AH
	   0A
 00000BC7  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000BCC  83 C2 10	     1	        add     edx, 10H        
 00000BCF		     1	??0031:     ; Get src pointer back to misaligned state
 00000BCF  03 F0	     1	        add     esi, eax
 00000BD1  E9 FFFFF599	     1	        jmp     C200
 00000BD6			E10B:   MOVE_UNALIGNED_SSSE3 0BH
 00000BD6  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000BDB		     1	??0032:     ; Loop. ecx has negative index from the end, counting up to zero
 00000BDB  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000BE1  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000BE7  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000BEB  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000BEF  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 0BH          ; Combine parts into aligned block
	   0B
 00000BF5  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 0BH          ; Combine parts into aligned block
	   0B
 00000BFB  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000C00  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000C06  83 C1 20	     1	        add     ecx, 20H
 00000C09  75 D0	     1	        jnz     ??0032
 00000C0B  03 F2	     1	        add     esi, edx
 00000C0D  03 FA	     1	        add     edi, edx
 00000C0F  F7 DA	     1	        neg     edx
 00000C11  83 FA F0	     1	        cmp     edx, -10H
 00000C14  7F 14	     1	        jg      ??0033
 00000C16  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000C1C  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 0BH
	   0B
 00000C22  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000C27  83 C2 10	     1	        add     edx, 10H        
 00000C2A		     1	??0033:     ; Get src pointer back to misaligned state
 00000C2A  03 F0	     1	        add     esi, eax
 00000C2C  E9 FFFFF53E	     1	        jmp     C200
 00000C31			E10C:   MOVE_UNALIGNED_SSSE3 0CH
 00000C31  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000C36		     1	??0034:     ; Loop. ecx has negative index from the end, counting up to zero
 00000C36  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000C3C  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000C42  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000C46  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000C4A  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 0CH          ; Combine parts into aligned block
	   0C 20
 00000C50  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 0CH          ; Combine parts into aligned block
	   0C 20
 00000C56  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000C5B  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000C61  83 C1 20	     1	        add     ecx, 20H
 00000C64  75 D0	     1	        jnz     ??0034
 00000C66  03 F2	     1	        add     esi, edx
 00000C68  03 FA	     1	        add     edi, edx
 00000C6A  F7 DA	     1	        neg     edx
 00000C6C  83 FA F0	     1	        cmp     edx, -10H
 00000C6F  7F 14	     1	        jg      ??0035
 00000C71  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000C77  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 0CH
	   0C 20
 00000C7D  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000C82  83 C2 10	     1	        add     edx, 10H        
 00000C85		     1	??0035:     ; Get src pointer back to misaligned state
 00000C85  03 F0	     1	        add     esi, eax
 00000C87  E9 FFFFF4E3	     1	        jmp     C200
				align   8
 00000C90			E10D:   MOVE_UNALIGNED_SSSE3 0DH
 00000C90  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000C95		     1	??0036:     ; Loop. ecx has negative index from the end, counting up to zero
 00000C95  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000C9B  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000CA1  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000CA5  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000CA9  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 0DH          ; Combine parts into aligned block
	   0D
 00000CAF  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 0DH          ; Combine parts into aligned block
	   0D
 00000CB5  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000CBA  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000CC0  83 C1 20	     1	        add     ecx, 20H
 00000CC3  75 D0	     1	        jnz     ??0036
 00000CC5  03 F2	     1	        add     esi, edx
 00000CC7  03 FA	     1	        add     edi, edx
 00000CC9  F7 DA	     1	        neg     edx
 00000CCB  83 FA F0	     1	        cmp     edx, -10H
 00000CCE  7F 14	     1	        jg      ??0037
 00000CD0  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000CD6  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 0DH
	   0D
 00000CDC  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000CE1  83 C2 10	     1	        add     edx, 10H        
 00000CE4		     1	??0037:     ; Get src pointer back to misaligned state
 00000CE4  03 F0	     1	        add     esi, eax
 00000CE6  E9 FFFFF484	     1	        jmp     C200
 00000CEB			E10E:   MOVE_UNALIGNED_SSSE3 0EH
 00000CEB  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000CF0		     1	??0038:     ; Loop. ecx has negative index from the end, counting up to zero
 00000CF0  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000CF6  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000CFC  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000D00  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000D04  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 0EH          ; Combine parts into aligned block
	   0E
 00000D0A  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 0EH          ; Combine parts into aligned block
	   0E
 00000D10  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000D15  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000D1B  83 C1 20	     1	        add     ecx, 20H
 00000D1E  75 D0	     1	        jnz     ??0038
 00000D20  03 F2	     1	        add     esi, edx
 00000D22  03 FA	     1	        add     edi, edx
 00000D24  F7 DA	     1	        neg     edx
 00000D26  83 FA F0	     1	        cmp     edx, -10H
 00000D29  7F 14	     1	        jg      ??0039
 00000D2B  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000D31  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 0EH
	   0E
 00000D37  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000D3C  83 C2 10	     1	        add     edx, 10H        
 00000D3F		     1	??0039:     ; Get src pointer back to misaligned state
 00000D3F  03 F0	     1	        add     esi, eax
 00000D41  E9 FFFFF429	     1	        jmp     C200
 00000D46			E10F:   MOVE_UNALIGNED_SSSE3 0FH
 00000D46  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000D4B		     1	??003A:     ; Loop. ecx has negative index from the end, counting up to zero
 00000D4B  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+10H]    ; Read next two blocks
	   10
 00000D51  66| 0F 6F 5C 31   1	        movdqa  xmm3, [esi+ecx+20H]
	   20
 00000D57  66| 0F 6F C8	     1	        movdqa  xmm1, xmm0             ; Save xmm0
 00000D5B  66| 0F 6F C3	     1	        movdqa  xmm0, xmm3             ; Save for next iteration
 00000D5F  66| 0F 3A 0F DA   1	        palignr xmm3, xmm2, 0FH          ; Combine parts into aligned block
	   0F
 00000D65  66| 0F 3A 0F D1   1	        palignr xmm2, xmm1, 0FH          ; Combine parts into aligned block
	   0F
 00000D6B  66| 0F 7F 14 39   1	        movdqa  [edi+ecx], xmm2        ; Save aligned
 00000D70  66| 0F 7F 5C 39   1	        movdqa  [edi+ecx+10H], xmm3    ; Save aligned
	   10
 00000D76  83 C1 20	     1	        add     ecx, 20H
 00000D79  75 D0	     1	        jnz     ??003A
 00000D7B  03 F2	     1	        add     esi, edx
 00000D7D  03 FA	     1	        add     edi, edx
 00000D7F  F7 DA	     1	        neg     edx
 00000D81  83 FA F0	     1	        cmp     edx, -10H
 00000D84  7F 14	     1	        jg      ??003B
 00000D86  66| 0F 6F 54 32   1	        movdqa  xmm2, [esi+edx+10H]
	   10
 00000D8C  66| 0F 3A 0F D0   1	        palignr xmm2, xmm0, 0FH
	   0F
 00000D92  66| 0F 7F 14 3A   1	        movdqa  [edi+edx], xmm2
 00000D97  83 C2 10	     1	        add     edx, 10H        
 00000D9A		     1	??003B:     ; Get src pointer back to misaligned state
 00000D9A  03 F0	     1	        add     esi, eax
 00000D9C  E9 FFFFF3CE	     1	        jmp     C200

				; Codes for non-temporal move. Aligned case first

 00000DA1			F100:   ; Non-temporal move, src and dest have same alignment.
				        ; Loop. ecx has negative index from the end, counting up to zero
 00000DA1  0F 28 04 31		        movaps  xmm0, [esi+ecx]        ; Read
 00000DA5  0F 28 4C 31 10	        movaps  xmm1, [esi+ecx+10H]
 00000DAA  0F 2B 04 39		        movntps [edi+ecx], xmm0        ; Write non-temporal (bypass cache)
 00000DAE  0F 2B 4C 39 10	        movntps [edi+ecx+10H], xmm1
 00000DB3  83 C1 20		        add     ecx, 20H
 00000DB6  75 E9		        jnz     F100                   ; Loop through negative ecx up to zero
				                
				        ; Move the remaining edx bytes (0 - 31):
 00000DB8  03 F2		        add     esi, edx
 00000DBA  03 FA		        add     edi, edx
 00000DBC  F7 DA		        neg     edx
 00000DBE  0F 84 FFFFF3E9	        jz      C500                   ; Skip if no more data
				        ; Check if we can more one more 16-bytes block
 00000DC4  83 FA F0		        cmp     edx, -10H
 00000DC7  0F 8F FFFFF3A2	        jg      C200
				        ; move 16 bytes, aligned
 00000DCD  0F 28 04 32		        movaps  xmm0, [esi+edx]
 00000DD1  0F 2B 04 3A		        movntps [edi+edx], xmm0
 00000DD5  83 C2 10		        add     edx, 10H
				        ; move the remaining 0 - 15 bytes
 00000DD8  E9 FFFFF392		        jmp     C200

				; Make 15 instances of MOVE_UNALIGNED_SSE2 macro for each value of 
				; the alignment u.
				; These are pointed to by the jump table AlignmentDispatchNT below

 00000DDD			F101:   MOVE_UNALIGNED_SSE2 1,   1
 00000DDD  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000DE2		     1	??003C:    ; Loop. ecx has negative index from the end, counting up to zero
 00000DE2  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000DE8  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000DEE  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000DF2  66| 0F 73 D8	     1	        psrldq  xmm0, 1                ; shift right
	   01
 00000DF7  66| 0F 73 F9	     1	        pslldq  xmm1, 16-1             ; shift left
	   0F
 00000DFC  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000E00  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00000E05  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000E09  66| 0F 73 DB	     1	        psrldq  xmm3, 1                ; shift right
	   01
 00000E0E  66| 0F 73 FA	     1	        pslldq  xmm2, 16-1             ; shift left
	   0F
 00000E13  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000E17  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 00000E1D  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000E20  75 C0	     1	        jnz     ??003C
 00000E22  03 F2	     1	        add     esi, edx
 00000E24  03 FA	     1	        add     edi, edx
 00000E26  F7 DA	     1	        neg     edx
 00000E28  83 FA F0	     1	        cmp     edx, -10H
 00000E2B  7F 1C	     1	        jg      ??003D
 00000E2D  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00000E33  66| 0F 73 D8	     1	        psrldq  xmm0, 1                ; shift right
	   01
 00000E38  66| 0F 73 F9	     1	        pslldq  xmm1, 16-1             ; shift left
	   0F
 00000E3D  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000E41  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 00000E46  83 C2 10	     1	        add     edx, 10H        
 00000E49		     1	??003D:     ; Get src pointer back to misaligned state
 00000E49  03 F0	     1	        add     esi, eax
 00000E4B  E9 FFFFF31F	     1	        jmp     C200
 00000E50			F102:   MOVE_UNALIGNED_SSE2 2,   1
 00000E50  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000E55		     1	??003E:    ; Loop. ecx has negative index from the end, counting up to zero
 00000E55  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000E5B  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000E61  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000E65  66| 0F 73 D8	     1	        psrldq  xmm0, 2                ; shift right
	   02
 00000E6A  66| 0F 73 F9	     1	        pslldq  xmm1, 16-2             ; shift left
	   0E
 00000E6F  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000E73  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00000E78  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000E7C  66| 0F 73 DB	     1	        psrldq  xmm3, 2                ; shift right
	   02
 00000E81  66| 0F 73 FA	     1	        pslldq  xmm2, 16-2             ; shift left
	   0E
 00000E86  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000E8A  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 00000E90  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000E93  75 C0	     1	        jnz     ??003E
 00000E95  03 F2	     1	        add     esi, edx
 00000E97  03 FA	     1	        add     edi, edx
 00000E99  F7 DA	     1	        neg     edx
 00000E9B  83 FA F0	     1	        cmp     edx, -10H
 00000E9E  7F 1C	     1	        jg      ??003F
 00000EA0  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00000EA6  66| 0F 73 D8	     1	        psrldq  xmm0, 2                ; shift right
	   02
 00000EAB  66| 0F 73 F9	     1	        pslldq  xmm1, 16-2             ; shift left
	   0E
 00000EB0  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000EB4  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 00000EB9  83 C2 10	     1	        add     edx, 10H        
 00000EBC		     1	??003F:     ; Get src pointer back to misaligned state
 00000EBC  03 F0	     1	        add     esi, eax
 00000EBE  E9 FFFFF2AC	     1	        jmp     C200
 00000EC3			F103:   MOVE_UNALIGNED_SSE2 3,   1
 00000EC3  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000EC8		     1	??0040:    ; Loop. ecx has negative index from the end, counting up to zero
 00000EC8  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000ECE  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000ED4  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000ED8  66| 0F 73 D8	     1	        psrldq  xmm0, 3                ; shift right
	   03
 00000EDD  66| 0F 73 F9	     1	        pslldq  xmm1, 16-3             ; shift left
	   0D
 00000EE2  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000EE6  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00000EEB  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000EEF  66| 0F 73 DB	     1	        psrldq  xmm3, 3                ; shift right
	   03
 00000EF4  66| 0F 73 FA	     1	        pslldq  xmm2, 16-3             ; shift left
	   0D
 00000EF9  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000EFD  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 00000F03  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000F06  75 C0	     1	        jnz     ??0040
 00000F08  03 F2	     1	        add     esi, edx
 00000F0A  03 FA	     1	        add     edi, edx
 00000F0C  F7 DA	     1	        neg     edx
 00000F0E  83 FA F0	     1	        cmp     edx, -10H
 00000F11  7F 1C	     1	        jg      ??0041
 00000F13  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00000F19  66| 0F 73 D8	     1	        psrldq  xmm0, 3                ; shift right
	   03
 00000F1E  66| 0F 73 F9	     1	        pslldq  xmm1, 16-3             ; shift left
	   0D
 00000F23  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000F27  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 00000F2C  83 C2 10	     1	        add     edx, 10H        
 00000F2F		     1	??0041:     ; Get src pointer back to misaligned state
 00000F2F  03 F0	     1	        add     esi, eax
 00000F31  E9 FFFFF239	     1	        jmp     C200
 00000F36			F104:   MOVE_UNALIGNED_SSE2_4    1
 00000F36  0F 28 04 31	     1	        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000F3A		     1	??0042:     ; Loop. ecx has negative index from the end, counting up to zero
 00000F3A  0F 28 4C 31 10    1	        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
 00000F3F  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1             ; Moves 4 bytes, leaves remaining bytes unchanged
 00000F43  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 00111001B
	   39
 00000F48  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Non-temporal save
 00000F4D  0F 28 44 31 20    1	        movaps  xmm0, [esi+ecx+20H]
 00000F52  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0
 00000F56  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 00111001B
	   39
 00000F5B  66| 0F E7 4C 39   1	        movntdq [edi+ecx+10H], xmm1    ; Non-temporal save
	   10
 00000F61  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000F64  75 D4	     1	        jnz     ??0042        
 00000F66  03 F2	     1	        add     esi, edx
 00000F68  03 FA	     1	        add     edi, edx
 00000F6A  F7 DA	     1	        neg     edx
 00000F6C  83 FA F0	     1	        cmp     edx, -10H
 00000F6F  7F 16	     1	        jg      ??0043
 00000F71  0F 28 4C 32 10    1	        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
 00000F76  F3/ 0F 10 C1	     1	        movss   xmm0, xmm1
 00000F7A  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 00111001B
	   39
 00000F7F  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; Non-temporal save
 00000F84  83 C2 10	     1	        add     edx, 10H        
 00000F87		     1	??0043:     ; Get src pointer back to misaligned state
 00000F87  03 F0	     1	        add     esi, eax
 00000F89  E9 FFFFF1E1	     1	        jmp     C200
 00000F8E			F105:   MOVE_UNALIGNED_SSE2 5,   1
 00000F8E  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00000F93		     1	??0044:    ; Loop. ecx has negative index from the end, counting up to zero
 00000F93  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00000F99  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00000F9F  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00000FA3  66| 0F 73 D8	     1	        psrldq  xmm0, 5                ; shift right
	   05
 00000FA8  66| 0F 73 F9	     1	        pslldq  xmm1, 16-5             ; shift left
	   0B
 00000FAD  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000FB1  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00000FB6  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00000FBA  66| 0F 73 DB	     1	        psrldq  xmm3, 5                ; shift right
	   05
 00000FBF  66| 0F 73 FA	     1	        pslldq  xmm2, 16-5             ; shift left
	   0B
 00000FC4  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00000FC8  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 00000FCE  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00000FD1  75 C0	     1	        jnz     ??0044
 00000FD3  03 F2	     1	        add     esi, edx
 00000FD5  03 FA	     1	        add     edi, edx
 00000FD7  F7 DA	     1	        neg     edx
 00000FD9  83 FA F0	     1	        cmp     edx, -10H
 00000FDC  7F 1C	     1	        jg      ??0045
 00000FDE  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00000FE4  66| 0F 73 D8	     1	        psrldq  xmm0, 5                ; shift right
	   05
 00000FE9  66| 0F 73 F9	     1	        pslldq  xmm1, 16-5             ; shift left
	   0B
 00000FEE  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00000FF2  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 00000FF7  83 C2 10	     1	        add     edx, 10H        
 00000FFA		     1	??0045:     ; Get src pointer back to misaligned state
 00000FFA  03 F0	     1	        add     esi, eax
 00000FFC  E9 FFFFF16E	     1	        jmp     C200
 00001001			F106:   MOVE_UNALIGNED_SSE2 6,   1
 00001001  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00001006		     1	??0046:    ; Loop. ecx has negative index from the end, counting up to zero
 00001006  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 0000100C  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00001012  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001016  66| 0F 73 D8	     1	        psrldq  xmm0, 6                ; shift right
	   06
 0000101B  66| 0F 73 F9	     1	        pslldq  xmm1, 16-6             ; shift left
	   0A
 00001020  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001024  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00001029  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000102D  66| 0F 73 DB	     1	        psrldq  xmm3, 6                ; shift right
	   06
 00001032  66| 0F 73 FA	     1	        pslldq  xmm2, 16-6             ; shift left
	   0A
 00001037  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 0000103B  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 00001041  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00001044  75 C0	     1	        jnz     ??0046
 00001046  03 F2	     1	        add     esi, edx
 00001048  03 FA	     1	        add     edi, edx
 0000104A  F7 DA	     1	        neg     edx
 0000104C  83 FA F0	     1	        cmp     edx, -10H
 0000104F  7F 1C	     1	        jg      ??0047
 00001051  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00001057  66| 0F 73 D8	     1	        psrldq  xmm0, 6                ; shift right
	   06
 0000105C  66| 0F 73 F9	     1	        pslldq  xmm1, 16-6             ; shift left
	   0A
 00001061  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001065  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 0000106A  83 C2 10	     1	        add     edx, 10H        
 0000106D		     1	??0047:     ; Get src pointer back to misaligned state
 0000106D  03 F0	     1	        add     esi, eax
 0000106F  E9 FFFFF0FB	     1	        jmp     C200
 00001074			F107:   MOVE_UNALIGNED_SSE2 7,   1
 00001074  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00001079		     1	??0048:    ; Loop. ecx has negative index from the end, counting up to zero
 00001079  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 0000107F  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00001085  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001089  66| 0F 73 D8	     1	        psrldq  xmm0, 7                ; shift right
	   07
 0000108E  66| 0F 73 F9	     1	        pslldq  xmm1, 16-7             ; shift left
	   09
 00001093  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001097  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 0000109C  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000010A0  66| 0F 73 DB	     1	        psrldq  xmm3, 7                ; shift right
	   07
 000010A5  66| 0F 73 FA	     1	        pslldq  xmm2, 16-7             ; shift left
	   09
 000010AA  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000010AE  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 000010B4  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000010B7  75 C0	     1	        jnz     ??0048
 000010B9  03 F2	     1	        add     esi, edx
 000010BB  03 FA	     1	        add     edi, edx
 000010BD  F7 DA	     1	        neg     edx
 000010BF  83 FA F0	     1	        cmp     edx, -10H
 000010C2  7F 1C	     1	        jg      ??0049
 000010C4  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 000010CA  66| 0F 73 D8	     1	        psrldq  xmm0, 7                ; shift right
	   07
 000010CF  66| 0F 73 F9	     1	        pslldq  xmm1, 16-7             ; shift left
	   09
 000010D4  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000010D8  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 000010DD  83 C2 10	     1	        add     edx, 10H        
 000010E0		     1	??0049:     ; Get src pointer back to misaligned state
 000010E0  03 F0	     1	        add     esi, eax
 000010E2  E9 FFFFF088	     1	        jmp     C200
 000010E7			F108:   MOVE_UNALIGNED_SSE2_8    1
 000010E7  0F 28 04 31	     1	        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000010EB		     1	??004A:     ; Loop. ecx has negative index from the end, counting up to zero
 000010EB  0F 28 4C 31 10    1	        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
 000010F0  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1             ; Moves 8 bytes, leaves remaining bytes unchanged
 000010F4  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B  ; Rotate
 000010F8  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; Non-temporal save
 000010FD  0F 28 44 31 20    1	        movaps  xmm0, [esi+ecx+20H]
 00001102  F2/ 0F 10 C8	     1	        movsd   xmm1, xmm0
 00001106  0F C6 C9 4E	     1	        shufps  xmm1, xmm1, 01001110B
 0000110A  66| 0F E7 4C 39   1	        movntdq [edi+ecx+10H], xmm1    ; Non-temporal save
	   10
 00001110  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00001113  75 D6	     1	        jnz     ??004A        
 00001115  03 F2	     1	        add     esi, edx
 00001117  03 FA	     1	        add     edi, edx
 00001119  F7 DA	     1	        neg     edx
 0000111B  83 FA F0	     1	        cmp     edx, -10H
 0000111E  7F 15	     1	        jg      ??004B
 00001120  0F 28 4C 32 10    1	        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
 00001125  F2/ 0F 10 C1	     1	        movsd   xmm0, xmm1
 00001129  0F C6 C0 4E	     1	        shufps  xmm0, xmm0, 01001110B
 0000112D  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; Non-temporal save
 00001132  83 C2 10	     1	        add     edx, 10H        
 00001135		     1	??004B:     ; Get src pointer back to misaligned state
 00001135  03 F0	     1	        add     esi, eax
 00001137  E9 FFFFF033	     1	        jmp     C200
 0000113C			F109:   MOVE_UNALIGNED_SSE2 9,   1
 0000113C  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00001141		     1	??004C:    ; Loop. ecx has negative index from the end, counting up to zero
 00001141  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00001147  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 0000114D  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001151  66| 0F 73 D8	     1	        psrldq  xmm0, 9                ; shift right
	   09
 00001156  66| 0F 73 F9	     1	        pslldq  xmm1, 16-9             ; shift left
	   07
 0000115B  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000115F  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00001164  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00001168  66| 0F 73 DB	     1	        psrldq  xmm3, 9                ; shift right
	   09
 0000116D  66| 0F 73 FA	     1	        pslldq  xmm2, 16-9             ; shift left
	   07
 00001172  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00001176  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 0000117C  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 0000117F  75 C0	     1	        jnz     ??004C
 00001181  03 F2	     1	        add     esi, edx
 00001183  03 FA	     1	        add     edi, edx
 00001185  F7 DA	     1	        neg     edx
 00001187  83 FA F0	     1	        cmp     edx, -10H
 0000118A  7F 1C	     1	        jg      ??004D
 0000118C  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00001192  66| 0F 73 D8	     1	        psrldq  xmm0, 9                ; shift right
	   09
 00001197  66| 0F 73 F9	     1	        pslldq  xmm1, 16-9             ; shift left
	   07
 0000119C  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000011A0  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 000011A5  83 C2 10	     1	        add     edx, 10H        
 000011A8		     1	??004D:     ; Get src pointer back to misaligned state
 000011A8  03 F0	     1	        add     esi, eax
 000011AA  E9 FFFFEFC0	     1	        jmp     C200
 000011AF			F10A:   MOVE_UNALIGNED_SSE2 0AH, 1
 000011AF  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000011B4		     1	??004E:    ; Loop. ecx has negative index from the end, counting up to zero
 000011B4  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000011BA  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000011C0  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000011C4  66| 0F 73 D8	     1	        psrldq  xmm0, 0AH                ; shift right
	   0A
 000011C9  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0AH             ; shift left
	   06
 000011CE  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000011D2  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 000011D7  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 000011DB  66| 0F 73 DB	     1	        psrldq  xmm3, 0AH                ; shift right
	   0A
 000011E0  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0AH             ; shift left
	   06
 000011E5  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000011E9  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 000011EF  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000011F2  75 C0	     1	        jnz     ??004E
 000011F4  03 F2	     1	        add     esi, edx
 000011F6  03 FA	     1	        add     edi, edx
 000011F8  F7 DA	     1	        neg     edx
 000011FA  83 FA F0	     1	        cmp     edx, -10H
 000011FD  7F 1C	     1	        jg      ??004F
 000011FF  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00001205  66| 0F 73 D8	     1	        psrldq  xmm0, 0AH                ; shift right
	   0A
 0000120A  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0AH             ; shift left
	   06
 0000120F  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001213  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 00001218  83 C2 10	     1	        add     edx, 10H        
 0000121B		     1	??004F:     ; Get src pointer back to misaligned state
 0000121B  03 F0	     1	        add     esi, eax
 0000121D  E9 FFFFEF4D	     1	        jmp     C200
 00001222			F10B:   MOVE_UNALIGNED_SSE2 0BH, 1
 00001222  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00001227		     1	??0050:    ; Loop. ecx has negative index from the end, counting up to zero
 00001227  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 0000122D  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00001233  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001237  66| 0F 73 D8	     1	        psrldq  xmm0, 0BH                ; shift right
	   0B
 0000123C  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0BH             ; shift left
	   05
 00001241  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001245  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 0000124A  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000124E  66| 0F 73 DB	     1	        psrldq  xmm3, 0BH                ; shift right
	   0B
 00001253  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0BH             ; shift left
	   05
 00001258  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 0000125C  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 00001262  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00001265  75 C0	     1	        jnz     ??0050
 00001267  03 F2	     1	        add     esi, edx
 00001269  03 FA	     1	        add     edi, edx
 0000126B  F7 DA	     1	        neg     edx
 0000126D  83 FA F0	     1	        cmp     edx, -10H
 00001270  7F 1C	     1	        jg      ??0051
 00001272  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00001278  66| 0F 73 D8	     1	        psrldq  xmm0, 0BH                ; shift right
	   0B
 0000127D  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0BH             ; shift left
	   05
 00001282  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001286  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 0000128B  83 C2 10	     1	        add     edx, 10H        
 0000128E		     1	??0051:     ; Get src pointer back to misaligned state
 0000128E  03 F0	     1	        add     esi, eax
 00001290  E9 FFFFEEDA	     1	        jmp     C200
 00001295			F10C:   MOVE_UNALIGNED_SSE2_12   1
 00001295  0F 28 04 31	     1	        movaps  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00001299  66| 0F 70 C0	     1	        pshufd  xmm0, xmm0, 10010011B
	   93
 0000129E		     1	??0052:     ; Loop. ecx has negative index from the end, counting up to zero
 0000129E  0F 28 4C 31 10    1	        movaps  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
 000012A3  0F 28 54 31 20    1	        movaps  xmm2, [esi+ecx+20H]
 000012A8  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B
	   93
 000012AD  66| 0F 70 D2	     1	        pshufd  xmm2, xmm2, 10010011B
	   93
 000012B2  0F 28 DA	     1	        movaps  xmm3, xmm2
 000012B5  F3/ 0F 10 D1	     1	        movss   xmm2, xmm1             ; Moves 4 bytes, leaves remaining bytes unchanged
 000012B9  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0             ; Moves 4 bytes, leaves remaining bytes unchanged       
 000012BD  66| 0F E7 0C 39   1	        movntdq [edi+ecx], xmm1        ; Non-temporal save
 000012C2  66| 0F E7 54 39   1	        movntdq [edi+ecx+10H], xmm2    ; Non-temporal save
	   10
 000012C8  0F 28 C3	     1	        movaps  xmm0, xmm3             ; Save for next iteration        
 000012CB  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000012CE  75 CE	     1	        jnz     ??0052        
 000012D0  03 F2	     1	        add     esi, edx
 000012D2  03 FA	     1	        add     edi, edx
 000012D4  F7 DA	     1	        neg     edx
 000012D6  83 FA F0	     1	        cmp     edx, -10H
 000012D9  7F 16	     1	        jg      ??0053
 000012DB  0F 28 4C 32 10    1	        movaps  xmm1, [esi+edx+10H]    ; Read next two blocks aligned
 000012E0  66| 0F 70 C9	     1	        pshufd  xmm1, xmm1, 10010011B
	   93
 000012E5  F3/ 0F 10 C8	     1	        movss   xmm1, xmm0             ; Moves 4 bytes, leaves remaining bytes unchanged       
 000012E9  66| 0F E7 0C 3A   1	        movntdq [edi+edx], xmm1        ; Non-temporal save
 000012EE  83 C2 10	     1	        add     edx, 10H        
 000012F1		     1	??0053:     ; Get src pointer back to misaligned state
 000012F1  03 F0	     1	        add     esi, eax
 000012F3  E9 FFFFEE77	     1	        jmp     C200
 000012F8			F10D:   MOVE_UNALIGNED_SSE2 0DH, 1
 000012F8  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000012FD		     1	??0054:    ; Loop. ecx has negative index from the end, counting up to zero
 000012FD  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00001303  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 00001309  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 0000130D  66| 0F 73 D8	     1	        psrldq  xmm0, 0DH                ; shift right
	   0D
 00001312  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0DH             ; shift left
	   03
 00001317  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000131B  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00001320  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00001324  66| 0F 73 DB	     1	        psrldq  xmm3, 0DH                ; shift right
	   0D
 00001329  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0DH             ; shift left
	   03
 0000132E  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00001332  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 00001338  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 0000133B  75 C0	     1	        jnz     ??0054
 0000133D  03 F2	     1	        add     esi, edx
 0000133F  03 FA	     1	        add     edi, edx
 00001341  F7 DA	     1	        neg     edx
 00001343  83 FA F0	     1	        cmp     edx, -10H
 00001346  7F 1C	     1	        jg      ??0055
 00001348  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 0000134E  66| 0F 73 D8	     1	        psrldq  xmm0, 0DH                ; shift right
	   0D
 00001353  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0DH             ; shift left
	   03
 00001358  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000135C  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 00001361  83 C2 10	     1	        add     edx, 10H        
 00001364		     1	??0055:     ; Get src pointer back to misaligned state
 00001364  03 F0	     1	        add     esi, eax
 00001366  E9 FFFFEE04	     1	        jmp     C200
 0000136B			F10E:   MOVE_UNALIGNED_SSE2 0EH, 1
 0000136B  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 00001370		     1	??0056:    ; Loop. ecx has negative index from the end, counting up to zero
 00001370  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 00001376  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 0000137C  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 00001380  66| 0F 73 D8	     1	        psrldq  xmm0, 0EH                ; shift right
	   0E
 00001385  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0EH             ; shift left
	   02
 0000138A  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 0000138E  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00001393  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 00001397  66| 0F 73 DB	     1	        psrldq  xmm3, 0EH                ; shift right
	   0E
 0000139C  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0EH             ; shift left
	   02
 000013A1  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 000013A5  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 000013AB  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 000013AE  75 C0	     1	        jnz     ??0056
 000013B0  03 F2	     1	        add     esi, edx
 000013B2  03 FA	     1	        add     edi, edx
 000013B4  F7 DA	     1	        neg     edx
 000013B6  83 FA F0	     1	        cmp     edx, -10H
 000013B9  7F 1C	     1	        jg      ??0057
 000013BB  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 000013C1  66| 0F 73 D8	     1	        psrldq  xmm0, 0EH                ; shift right
	   0E
 000013C6  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0EH             ; shift left
	   02
 000013CB  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 000013CF  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 000013D4  83 C2 10	     1	        add     edx, 10H        
 000013D7		     1	??0057:     ; Get src pointer back to misaligned state
 000013D7  03 F0	     1	        add     esi, eax
 000013D9  E9 FFFFED91	     1	        jmp     C200
 000013DE			F10F:   MOVE_UNALIGNED_SSE2 0FH, 1
 000013DE  66| 0F 6F 04 31   1	        movdqa  xmm0, [esi+ecx]        ; Read from nearest preceding 16B boundary
 000013E3		     1	??0058:    ; Loop. ecx has negative index from the end, counting up to zero
 000013E3  66| 0F 6F 4C 31   1	        movdqa  xmm1, [esi+ecx+10H]    ; Read next two blocks aligned
	   10
 000013E9  66| 0F 6F 54 31   1	        movdqa  xmm2, [esi+ecx+20H]
	   20
 000013EF  66| 0F 6F D9	     1	        movdqa  xmm3, xmm1             ; Copy because used twice
 000013F3  66| 0F 73 D8	     1	        psrldq  xmm0, 0FH                ; shift right
	   0F
 000013F8  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0FH             ; shift left
	   01
 000013FD  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001401  66| 0F E7 04 39   1	        movntdq [edi+ecx], xmm0        ; non-temporal save
 00001406  66| 0F 6F C2	     1	        movdqa  xmm0, xmm2             ; Save for next iteration
 0000140A  66| 0F 73 DB	     1	        psrldq  xmm3, 0FH                ; shift right
	   0F
 0000140F  66| 0F 73 FA	     1	        pslldq  xmm2, 16-0FH             ; shift left
	   01
 00001414  66| 0F EB DA	     1	        por     xmm3, xmm2             ; combine blocks
 00001418  66| 0F E7 5C 39   1	        movntdq [edi+ecx+10H], xmm3    ; non-temporal save
	   10
 0000141E  83 C1 20	     1	        add     ecx, 20H               ; Loop through negative values up to zero
 00001421  75 C0	     1	        jnz     ??0058
 00001423  03 F2	     1	        add     esi, edx
 00001425  03 FA	     1	        add     edi, edx
 00001427  F7 DA	     1	        neg     edx
 00001429  83 FA F0	     1	        cmp     edx, -10H
 0000142C  7F 1C	     1	        jg      ??0059
 0000142E  66| 0F 6F 4C 32   1	        movdqa  xmm1, [esi+edx+10H]
	   10
 00001434  66| 0F 73 D8	     1	        psrldq  xmm0, 0FH                ; shift right
	   0F
 00001439  66| 0F 73 F9	     1	        pslldq  xmm1, 16-0FH             ; shift left
	   01
 0000143E  66| 0F EB C1	     1	        por     xmm0, xmm1             ; combine blocks
 00001442  66| 0F E7 04 3A   1	        movntdq [edi+edx], xmm0        ; non-temporal save
 00001447  83 C2 10	     1	        add     edx, 10H        
 0000144A		     1	??0059:     ; Get src pointer back to misaligned state
 0000144A  03 F0	     1	        add     esi, eax
 0000144C  E9 FFFFED1E	     1	        jmp     C200

				IFDEF   POSITIONINDEPENDENT
				ENDIF

				; 80386 version used when SSE2 not supported:
 00001451			memcpy386:
				; edi = dest
				; esi = src
				; ecx = count
 00001451  FC			        cld
 00001452  83 F9 08		        cmp     ecx, 8
 00001455  72 2C		        jb      G500
 00001457  F7 C7 00000001	G100:   test    edi, 1
 0000145D  74 02		        jz      G200
 0000145F  A4			        movsb
 00001460  49			        dec     ecx
 00001461  F7 C7 00000002	G200:   test    edi, 2
 00001467  74 05		        jz      G300
 00001469  66| A5		        movsw
 0000146B  83 E9 02		        sub     ecx, 2
 0000146E			G300:   ; edi is aligned now
 0000146E  8B D1		        mov     edx, ecx
 00001470  C1 E9 02		        shr     ecx, 2
 00001473  F3/ A5		        rep     movsd                  ; move 4 bytes at a time
 00001475  8B CA		        mov     ecx, edx
 00001477  83 E1 03		        and     ecx, 3
 0000147A  F3/ A4		        rep     movsb                  ; move remaining 0-3 bytes
				        RETURNM
 0000147C  5F		     1	        pop     edi
 0000147D  5E		     1	        pop     esi
 0000147E  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 00001482  C3		     1	        ret
				        
 00001483			G500:   ; count < 8. Move one byte at a time
 00001483  F3/ A4		        rep     movsb                  ; move count bytes
				        RETURNM
 00001485  5F		     1	        pop     edi
 00001486  5E		     1	        pop     esi
 00001487  8B 44 24 04	     1	        mov     eax, [esp+4]           ; Return value = dest
 0000148B  C3		     1	        ret
				        
				; CPU dispatching for memcpy. This is executed only once
 0000148C			memcpyCPUDispatch:
				IFNDEF   POSITIONINDEPENDENT
 0000148C  60			        pushad
 0000148D  E8 00000000 E	        call    _InstructionSet
				        ; Point to generic version of memcpy
 00001492  C7 05 000000C0 R	        mov     [memcpyDispatch], offset memcpy386
	   00001451 R
 0000149C  83 F8 04		        cmp     eax, 4                 ; check SSE2
 0000149F  72 21		        jb      M100
				        ; SSE2 supported
				        ; Point to SSE2 and later version of memcpy
 000014A1  C7 05 000000C0 R	        mov     [memcpyDispatch], offset memcpySSE2
	   00000014 R
 000014AB  83 F8 06		        cmp     eax, 6                 ; check Suppl-SSE3
 000014AE  72 12		        jb      M100
				        ; Suppl-SSE3 supported
				        ; Replace alignment dispatch table with Suppl-SSE3 version        
 000014B0  BE 00000040 R	        mov     esi, offset AlignmentDispatchSupSSE3
 000014B5  BF 00000000 R	        mov     edi, offset AlignmentDispatchSSE2
 000014BA  B9 00000010		        mov     ecx, 16
 000014BF  FC			        cld
 000014C0  F3/ A5		        rep     movsd
 000014C2  61			M100:   popad
				        ; Continue in appropriate version of memcpy
 000014C3  FF 25 000000C0 R	        jmp     [memcpyDispatch]

				ELSE    ; Position-independent version
				ENDIF


				; Data segment must be included in function namespace
 00000000			.data

				; Jump tables for alignments 0 - 15:
				; The CPU dispatcher replaces AlignmentDispatchSSE2 with 
				; AlignmentDispatchSupSSE3 if Suppl-SSE3 is supported
				; RP = reference point if position-independent code, otherwise RP = 0

 00000000			AlignmentDispatch label dword
				; Code pointer for each alignment for SSE2 instruction set
 00000000			AlignmentDispatchSSE2 label dword
 00000000  00000140 R		DD C100-RP, D101-RP, D102-RP, D103-RP, D104-RP, D105-RP, D106-RP, D107-RP
	   000001B4 R
	   00000227 R
	   0000029A R
	   00000310 R
	   00000368 R
	   000003DB R
	   00000450 R
 00000020  000004D0 R		DD D108-RP, D109-RP, D10A-RP, D10B-RP, D10C-RP, D10D-RP, D10E-RP, D10F-RP
	   00000525 R
	   00000598 R
	   0000060B R
	   00000680 R
	   000006E3 R
	   00000756 R
	   000007C9 R

				; Code pointer for each alignment for Suppl.SSE3 instruction set
 00000040			AlignmentDispatchSupSSE3 label dword
 00000040  00000140 R		DD C100-RP, E101-RP, E102-RP, E103-RP, E104-RP, E105-RP, E106-RP, E107-RP
	   00000840 R
	   0000089B R
	   000008F6 R
	   00000951 R
	   000009B0 R
	   00000A0B R
	   00000A66 R
 00000060  00000AC1 R		DD E108-RP, E109-RP, E10A-RP, E10B-RP, E10C-RP, E10D-RP, E10E-RP, E10F-RP
	   00000B20 R
	   00000B7B R
	   00000BD6 R
	   00000C31 R
	   00000C90 R
	   00000CEB R
	   00000D46 R

				; Code pointer for each alignment for non-temporal store
 00000080			AlignmentDispatchNT label dword
 00000080  00000DA1 R		DD F100-RP, F101-RP, F102-RP, F103-RP, F104-RP, F105-RP, F106-RP, F107-RP
	   00000DDD R
	   00000E50 R
	   00000EC3 R
	   00000F36 R
	   00000F8E R
	   00001001 R
	   00001074 R
 000000A0  000010E7 R		DD F108-RP, F109-RP, F10A-RP, F10B-RP, F10C-RP, F10D-RP, F10E-RP, F10F-RP
	   0000113C R
	   000011AF R
	   00001222 R
	   00001295 R
	   000012F8 R
	   0000136B R
	   000013DE R

				IFNDEF  POSITIONINDEPENDENT
				; Pointer to appropriate version.
				; This initially points to memcpyCPUDispatch. memcpyCPUDispatch will
				; change this to the appropriate version of memcpy, so that
				; memcpyCPUDispatch is only executed once:
 000000C0 0000148C R		memcpyDispatch DD memcpyCPUDispatch
				ELSE
				ENDIF

				; Bypass cache by using non-temporal moves if count > _CacheBypassLimit
				; The optimal value of _CacheBypassLimit is difficult to estimate, but
				; a reasonable value is half the size of the largest cache:
 000000C4 00400000		_CacheBypassLimit DD 400000H             ; 400000H = 4 Megabytes

 000014C9			.code
 000014C9			_A_memcpy ENDP                           ; End of function namespace

				END
Microsoft (R) Macro Assembler Version 9.00.21022.08	    08/06/09 23:17:55
memcpy32.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

MOVE_UNALIGNED_SSE2_12 . . . . .	Proc
MOVE_UNALIGNED_SSE2_4  . . . . .	Proc
MOVE_UNALIGNED_SSE2_8  . . . . .	Proc
MOVE_UNALIGNED_SSE2  . . . . . .	Proc
MOVE_UNALIGNED_SSSE3 . . . . . .	Proc
PICREFERENCE . . . . . . . . . .	Proc
RETURNM  . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 000000C8 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000014C9 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

_A_memcpy  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000014C9 Public
  memcpySSE2 . . . . . . . . . .	L Near	 00000014 _TEXT	
  A100 . . . . . . . . . . . . .	L Near	 00000059 _TEXT	
  A200 . . . . . . . . . . . . .	L Near	 00000077 _TEXT	
  A300 . . . . . . . . . . . . .	L Near	 00000089 _TEXT	
  A400 . . . . . . . . . . . . .	L Near	 00000099 _TEXT	
  A500 . . . . . . . . . . . . .	L Near	 000000A9 _TEXT	
  A900 . . . . . . . . . . . . .	L Near	 000000B5 _TEXT	
  B100 . . . . . . . . . . . . .	L Near	 000000BC _TEXT	
  B200 . . . . . . . . . . . . .	L Near	 000000DF _TEXT	
  B210 . . . . . . . . . . . . .	L Near	 000000ED _TEXT	
  B220 . . . . . . . . . . . . .	L Near	 000000FD _TEXT	
  B300 . . . . . . . . . . . . .	L Near	 00000109 _TEXT	
  B400 . . . . . . . . . . . . .	L Near	 0000012C _TEXT	
  C100 . . . . . . . . . . . . .	L Near	 00000140 _TEXT	
  C200 . . . . . . . . . . . . .	L Near	 0000016F _TEXT	
  C210 . . . . . . . . . . . . .	L Near	 00000183 _TEXT	
  C220 . . . . . . . . . . . . .	L Near	 00000191 _TEXT	
  C230 . . . . . . . . . . . . .	L Near	 000001A1 _TEXT	
  C500 . . . . . . . . . . . . .	L Near	 000001AD _TEXT	
  D101 . . . . . . . . . . . . .	L Near	 000001B4 _TEXT	
  ??0000 . . . . . . . . . . . .	L Near	 000001B9 _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 00000220 _TEXT	
  D102 . . . . . . . . . . . . .	L Near	 00000227 _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 0000022C _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 00000293 _TEXT	
  D103 . . . . . . . . . . . . .	L Near	 0000029A _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 0000029F _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 00000306 _TEXT	
  D104 . . . . . . . . . . . . .	L Near	 00000310 _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 00000314 _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 00000361 _TEXT	
  D105 . . . . . . . . . . . . .	L Near	 00000368 _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 0000036D _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 000003D4 _TEXT	
  D106 . . . . . . . . . . . . .	L Near	 000003DB _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 000003E0 _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 00000447 _TEXT	
  D107 . . . . . . . . . . . . .	L Near	 00000450 _TEXT	
  ??000C . . . . . . . . . . . .	L Near	 00000455 _TEXT	
  ??000D . . . . . . . . . . . .	L Near	 000004BC _TEXT	
  D108 . . . . . . . . . . . . .	L Near	 000004D0 _TEXT	
  ??000E . . . . . . . . . . . .	L Near	 000004D4 _TEXT	
  ??000F . . . . . . . . . . . .	L Near	 0000051E _TEXT	
  D109 . . . . . . . . . . . . .	L Near	 00000525 _TEXT	
  ??0010 . . . . . . . . . . . .	L Near	 0000052A _TEXT	
  ??0011 . . . . . . . . . . . .	L Near	 00000591 _TEXT	
  D10A . . . . . . . . . . . . .	L Near	 00000598 _TEXT	
  ??0012 . . . . . . . . . . . .	L Near	 0000059D _TEXT	
  ??0013 . . . . . . . . . . . .	L Near	 00000604 _TEXT	
  D10B . . . . . . . . . . . . .	L Near	 0000060B _TEXT	
  ??0014 . . . . . . . . . . . .	L Near	 00000610 _TEXT	
  ??0015 . . . . . . . . . . . .	L Near	 00000677 _TEXT	
  D10C . . . . . . . . . . . . .	L Near	 00000680 _TEXT	
  ??0016 . . . . . . . . . . . .	L Near	 00000689 _TEXT	
  ??0017 . . . . . . . . . . . .	L Near	 000006DC _TEXT	
  D10D . . . . . . . . . . . . .	L Near	 000006E3 _TEXT	
  ??0018 . . . . . . . . . . . .	L Near	 000006E8 _TEXT	
  ??0019 . . . . . . . . . . . .	L Near	 0000074F _TEXT	
  D10E . . . . . . . . . . . . .	L Near	 00000756 _TEXT	
  ??001A . . . . . . . . . . . .	L Near	 0000075B _TEXT	
  ??001B . . . . . . . . . . . .	L Near	 000007C2 _TEXT	
  D10F . . . . . . . . . . . . .	L Near	 000007C9 _TEXT	
  ??001C . . . . . . . . . . . .	L Near	 000007CE _TEXT	
  ??001D . . . . . . . . . . . .	L Near	 00000835 _TEXT	
  E101 . . . . . . . . . . . . .	L Near	 00000840 _TEXT	
  ??001E . . . . . . . . . . . .	L Near	 00000845 _TEXT	
  ??001F . . . . . . . . . . . .	L Near	 00000894 _TEXT	
  E102 . . . . . . . . . . . . .	L Near	 0000089B _TEXT	
  ??0020 . . . . . . . . . . . .	L Near	 000008A0 _TEXT	
  ??0021 . . . . . . . . . . . .	L Near	 000008EF _TEXT	
  E103 . . . . . . . . . . . . .	L Near	 000008F6 _TEXT	
  ??0022 . . . . . . . . . . . .	L Near	 000008FB _TEXT	
  ??0023 . . . . . . . . . . . .	L Near	 0000094A _TEXT	
  E104 . . . . . . . . . . . . .	L Near	 00000951 _TEXT	
  ??0024 . . . . . . . . . . . .	L Near	 00000956 _TEXT	
  ??0025 . . . . . . . . . . . .	L Near	 000009A5 _TEXT	
  E105 . . . . . . . . . . . . .	L Near	 000009B0 _TEXT	
  ??0026 . . . . . . . . . . . .	L Near	 000009B5 _TEXT	
  ??0027 . . . . . . . . . . . .	L Near	 00000A04 _TEXT	
  E106 . . . . . . . . . . . . .	L Near	 00000A0B _TEXT	
  ??0028 . . . . . . . . . . . .	L Near	 00000A10 _TEXT	
  ??0029 . . . . . . . . . . . .	L Near	 00000A5F _TEXT	
  E107 . . . . . . . . . . . . .	L Near	 00000A66 _TEXT	
  ??002A . . . . . . . . . . . .	L Near	 00000A6B _TEXT	
  ??002B . . . . . . . . . . . .	L Near	 00000ABA _TEXT	
  E108 . . . . . . . . . . . . .	L Near	 00000AC1 _TEXT	
  ??002C . . . . . . . . . . . .	L Near	 00000AC6 _TEXT	
  ??002D . . . . . . . . . . . .	L Near	 00000B15 _TEXT	
  E109 . . . . . . . . . . . . .	L Near	 00000B20 _TEXT	
  ??002E . . . . . . . . . . . .	L Near	 00000B25 _TEXT	
  ??002F . . . . . . . . . . . .	L Near	 00000B74 _TEXT	
  E10A . . . . . . . . . . . . .	L Near	 00000B7B _TEXT	
  ??0030 . . . . . . . . . . . .	L Near	 00000B80 _TEXT	
  ??0031 . . . . . . . . . . . .	L Near	 00000BCF _TEXT	
  E10B . . . . . . . . . . . . .	L Near	 00000BD6 _TEXT	
  ??0032 . . . . . . . . . . . .	L Near	 00000BDB _TEXT	
  ??0033 . . . . . . . . . . . .	L Near	 00000C2A _TEXT	
  E10C . . . . . . . . . . . . .	L Near	 00000C31 _TEXT	
  ??0034 . . . . . . . . . . . .	L Near	 00000C36 _TEXT	
  ??0035 . . . . . . . . . . . .	L Near	 00000C85 _TEXT	
  E10D . . . . . . . . . . . . .	L Near	 00000C90 _TEXT	
  ??0036 . . . . . . . . . . . .	L Near	 00000C95 _TEXT	
  ??0037 . . . . . . . . . . . .	L Near	 00000CE4 _TEXT	
  E10E . . . . . . . . . . . . .	L Near	 00000CEB _TEXT	
  ??0038 . . . . . . . . . . . .	L Near	 00000CF0 _TEXT	
  ??0039 . . . . . . . . . . . .	L Near	 00000D3F _TEXT	
  E10F . . . . . . . . . . . . .	L Near	 00000D46 _TEXT	
  ??003A . . . . . . . . . . . .	L Near	 00000D4B _TEXT	
  ??003B . . . . . . . . . . . .	L Near	 00000D9A _TEXT	
  F100 . . . . . . . . . . . . .	L Near	 00000DA1 _TEXT	
  F101 . . . . . . . . . . . . .	L Near	 00000DDD _TEXT	
  ??003C . . . . . . . . . . . .	L Near	 00000DE2 _TEXT	
  ??003D . . . . . . . . . . . .	L Near	 00000E49 _TEXT	
  F102 . . . . . . . . . . . . .	L Near	 00000E50 _TEXT	
  ??003E . . . . . . . . . . . .	L Near	 00000E55 _TEXT	
  ??003F . . . . . . . . . . . .	L Near	 00000EBC _TEXT	
  F103 . . . . . . . . . . . . .	L Near	 00000EC3 _TEXT	
  ??0040 . . . . . . . . . . . .	L Near	 00000EC8 _TEXT	
  ??0041 . . . . . . . . . . . .	L Near	 00000F2F _TEXT	
  F104 . . . . . . . . . . . . .	L Near	 00000F36 _TEXT	
  ??0042 . . . . . . . . . . . .	L Near	 00000F3A _TEXT	
  ??0043 . . . . . . . . . . . .	L Near	 00000F87 _TEXT	
  F105 . . . . . . . . . . . . .	L Near	 00000F8E _TEXT	
  ??0044 . . . . . . . . . . . .	L Near	 00000F93 _TEXT	
  ??0045 . . . . . . . . . . . .	L Near	 00000FFA _TEXT	
  F106 . . . . . . . . . . . . .	L Near	 00001001 _TEXT	
  ??0046 . . . . . . . . . . . .	L Near	 00001006 _TEXT	
  ??0047 . . . . . . . . . . . .	L Near	 0000106D _TEXT	
  F107 . . . . . . . . . . . . .	L Near	 00001074 _TEXT	
  ??0048 . . . . . . . . . . . .	L Near	 00001079 _TEXT	
  ??0049 . . . . . . . . . . . .	L Near	 000010E0 _TEXT	
  F108 . . . . . . . . . . . . .	L Near	 000010E7 _TEXT	
  ??004A . . . . . . . . . . . .	L Near	 000010EB _TEXT	
  ??004B . . . . . . . . . . . .	L Near	 00001135 _TEXT	
  F109 . . . . . . . . . . . . .	L Near	 0000113C _TEXT	
  ??004C . . . . . . . . . . . .	L Near	 00001141 _TEXT	
  ??004D . . . . . . . . . . . .	L Near	 000011A8 _TEXT	
  F10A . . . . . . . . . . . . .	L Near	 000011AF _TEXT	
  ??004E . . . . . . . . . . . .	L Near	 000011B4 _TEXT	
  ??004F . . . . . . . . . . . .	L Near	 0000121B _TEXT	
  F10B . . . . . . . . . . . . .	L Near	 00001222 _TEXT	
  ??0050 . . . . . . . . . . . .	L Near	 00001227 _TEXT	
  ??0051 . . . . . . . . . . . .	L Near	 0000128E _TEXT	
  F10C . . . . . . . . . . . . .	L Near	 00001295 _TEXT	
  ??0052 . . . . . . . . . . . .	L Near	 0000129E _TEXT	
  ??0053 . . . . . . . . . . . .	L Near	 000012F1 _TEXT	
  F10D . . . . . . . . . . . . .	L Near	 000012F8 _TEXT	
  ??0054 . . . . . . . . . . . .	L Near	 000012FD _TEXT	
  ??0055 . . . . . . . . . . . .	L Near	 00001364 _TEXT	
  F10E . . . . . . . . . . . . .	L Near	 0000136B _TEXT	
  ??0056 . . . . . . . . . . . .	L Near	 00001370 _TEXT	
  ??0057 . . . . . . . . . . . .	L Near	 000013D7 _TEXT	
  F10F . . . . . . . . . . . . .	L Near	 000013DE _TEXT	
  ??0058 . . . . . . . . . . . .	L Near	 000013E3 _TEXT	
  ??0059 . . . . . . . . . . . .	L Near	 0000144A _TEXT	
  memcpy386  . . . . . . . . . .	L Near	 00001451 _TEXT	
  G100 . . . . . . . . . . . . .	L Near	 00001457 _TEXT	
  G200 . . . . . . . . . . . . .	L Near	 00001461 _TEXT	
  G300 . . . . . . . . . . . . .	L Near	 0000146E _TEXT	
  G500 . . . . . . . . . . . . .	L Near	 00001483 _TEXT	
  memcpyCPUDispatch  . . . . . .	L Near	 0000148C _TEXT	
  M100 . . . . . . . . . . . . .	L Near	 000014C2 _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

$memcpyEntry2  . . . . . . . . .	L Near	 0000000E _TEXT	Public
?OVR_memcpy  . . . . . . . . . .	L Near	 00000000 _TEXT	Public
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
AlignmentDispatchNT  . . . . . .	DWord	 00000080 _DATA	
AlignmentDispatchSSE2  . . . . .	DWord	 00000000 _DATA	
AlignmentDispatchSupSSE3 . . . .	DWord	 00000040 _DATA	
AlignmentDispatch  . . . . . . .	DWord	 00000000 _DATA	
RP . . . . . . . . . . . . . . .	Number	 00000000h   
_CacheBypassLimit  . . . . . . .	DWord	 000000C4 _DATA	Public
_InstructionSet  . . . . . . . .	L Near	 00000000 FLAT	External
memcpyDispatch . . . . . . . . .	DWord	 000000C0 _DATA	

	   0 Warnings
	   0 Errors
